<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>1488. 避免洪水泛滥</title>
    <link href="/2021/08/15/1488-%E9%81%BF%E5%85%8D%E6%B4%AA%E6%B0%B4%E6%B3%9B%E6%BB%A5/"/>
    <url>/2021/08/15/1488-%E9%81%BF%E5%85%8D%E6%B4%AA%E6%B0%B4%E6%B3%9B%E6%BB%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/avoid-flood-in-the-city/">1488. 避免洪水泛滥 - 力扣（LeetCode）</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">rains[i]=0，天晴，可以抽水； &gt;0，那个湖泊下雨<br>贪心策略：遇到天晴，先不抽水；<br>等有湖泊水满了，再抽水<br><br>map 记录某湖泊最近一次蓄满水的日期。<br><span class="hljs-builtin-name">set</span> 哪个湖泊满了，存放进<span class="hljs-builtin-name">set</span><br>treeSet 存可以抽水的日期，<br></code></pre></td></tr></table></figure><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    rains[i]=0，天晴，可以抽水； &gt;0，那个湖泊下雨</span><br><span class="hljs-comment">    贪心策略：遇到天晴，先不抽水；</span><br><span class="hljs-comment">    等有湖泊水满了，再抽水</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    map 记录某湖泊最近一次蓄满水的日期。</span><br><span class="hljs-comment">    set 哪个湖泊满了，存放进set</span><br><span class="hljs-comment">    treeSet 存可以抽水的日期，</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] avoidFlood(<span class="hljs-keyword">int</span>[] rains)&#123;<br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[rains.length];<br>    <span class="hljs-comment">// 初始化答案 -1</span><br>    Arrays.fill(res, -<span class="hljs-number">1</span>);<br>    HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    HashSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>    TreeSet&lt;Integer&gt; tree = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rains.length; i++) &#123;<br>        <span class="hljs-comment">//天晴，可以抽水，记录下来</span><br>        <span class="hljs-keyword">if</span> (rains[i] == <span class="hljs-number">0</span>)&#123;<br>            tree.add(i);<br>            res[i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// 湖泊为空，先存水</span><br>        <span class="hljs-keyword">if</span> (!set.contains(rains[i]))&#123;<br>            set.add(rains[i]);<br>            map.put(rains[i], i); <span class="hljs-comment">//存放湖泊满的 日期</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// 贪心：查找map 湖泊满的日期，找天晴的日子（天晴的日子 要比 湖泊满的日子 晚！）</span><br>        <span class="hljs-comment">// 返回大于e的最小元素；如果没有这样的元素，则返回null。</span><br>        Integer t = tree.higher(map.get(rains[i]));<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>]; <span class="hljs-comment">//洪水泛滥</span><br>        <span class="hljs-comment">//当前日期变更为该湖泊的最近满水日期</span><br>        map.put(rains[i] , i);<br>        res[t] = rains[i]; <span class="hljs-comment">//天晴这天，抽rain[i]湖泊</span><br>        tree.remove(t);<br><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>279. 完全平方数</title>
    <link href="/2021/08/12/279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"/>
    <url>/2021/08/12/279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数 - 力扣（LeetCode）</a></p><p><img src="/2021/08/12/279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/image-20210812001027774.png" alt="image-20210812001027774"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-number">1</span>.<span class="hljs-keyword">dp</span>定义，<span class="hljs-keyword">dp</span>[i] 组成i的最少数量<br><span class="hljs-number">2</span>.递推公式，<span class="hljs-keyword">dp</span>[<span class="hljs-keyword">j</span>]有两种方式，添加一个平方数 或者 不添加<br>    <span class="hljs-keyword">dp</span>[<span class="hljs-keyword">j</span>] = <span class="hljs-built_in">min</span>(<span class="hljs-keyword">dp</span>[<span class="hljs-keyword">j</span>], <span class="hljs-keyword">dp</span>[<span class="hljs-keyword">j</span> - i*i] + <span class="hljs-number">1</span>)<br><span class="hljs-number">3</span>.初始化，<span class="hljs-keyword">dp</span>[<span class="hljs-number">0</span>]应该为<span class="hljs-number">0</span>，因为<span class="hljs-keyword">dp</span>[<span class="hljs-number">1</span>]是<span class="hljs-number">1</span>；非<span class="hljs-number">0</span>的位置，初始化为最大值<br><span class="hljs-number">4</span>.遍历顺序，完全背包问题，因为求最小数量，不管是排列还是组合都可以<br>    容量为n，物品为 <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">9</span> …<br><span class="hljs-number">5</span>.举例<br></code></pre></td></tr></table></figure><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 要将非0的位置，初始化为最大值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n+<span class="hljs-number">1</span>; i++) &#123;<br>        dp[i] = Integer.MAX_VALUE;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n+<span class="hljs-number">1</span>; i++) &#123; <span class="hljs-comment">//遍历背包</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j * j &lt;= i; j++) &#123; <span class="hljs-comment">//遍历物品</span><br>            dp[i] = Math.min(dp[i], dp[i-j*j]+<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>背包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>70. 爬楼梯</title>
    <link href="/2021/08/11/70-%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <url>/2021/08/11/70-%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯 - 力扣（LeetCode）</a></p><p><img src="/2021/08/11/70-%E7%88%AC%E6%A5%BC%E6%A2%AF/image-20210811235133640.png" alt="image-20210811235133640"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="递推公式"><a href="#递推公式" class="headerlink" title="递推公式"></a>递推公式</h3><p>f(n) = f(n-1) + f(n-2)</p><h3 id="完全背包解法"><a href="#完全背包解法" class="headerlink" title="完全背包解法"></a>完全背包解法</h3><p>完全背包的写法：<br>i级台阶可以理解为容量为i的背包 总金额，跳1级、跳2级可以理解为硬币金额</p><p>1.dp数组初始化：dp[i] i级台阶，有dp[i]种方法<br>2.递推公式，到达i级台阶，可以dp[i-1]、dp[i-2]<br>    dp[i] += dp[i-nums[j]]<br>3.初始化，dp[0]一定要是1，如果dp[0]是0的话，其他数值都是0了。<br>4.确定遍历顺序，<strong>排列问题</strong>，先跳1层台阶再跳2层台阶 和 先跳2层再跳1层 是两种<br>    因此先遍历背包target，再遍历物品nums[i]（内循环）<br>5.举例</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt; dp.length; i++) &#123;<br>        dp[i] = dp[i-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">2</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span>[] nums = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; nums.length; j++) &#123;<br>            <span class="hljs-comment">// 先遍历背包target，再遍历物品nums[i]（内循环）</span><br>            <span class="hljs-keyword">if</span> (i &gt;= nums[j])<br>                dp[i] += dp[i-nums[j]];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>背包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>377. 组合总和 Ⅳ</title>
    <link href="/2021/08/10/377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%E2%85%A3/"/>
    <url>/2021/08/10/377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%E2%85%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/combination-sum-iv/">377. 组合总和 Ⅳ - 力扣（LeetCode）</a></p><p><img src="/2021/08/10/377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%E2%85%A3/image-20210810234726503.png" alt="image-20210810234726503"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>完全背包问题，排列数</p><p>​    个数可以不限使⽤，说明这是⼀个完全背包。<br>​    得到的集合是排列，说明需要考虑元素之间的顺序。  </p><p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包。</strong><br><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品。</strong>  </p><p>如果把遍历nums（物品）放在外循环，遍历target的作为内循环的话，举⼀个例⼦：计算dp[4]的时<br>候，结果集只有 {1,3} 这样的集合，不会有{3,1}这样的集合，<strong>因为nums遍历放在外层， 3只能出现在1后</strong><br><strong>⾯！</strong></p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">combinationSum4</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[target + <span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; target+<span class="hljs-number">1</span>; i++) &#123; <span class="hljs-comment">//遍历背包容量</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; nums.length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt;= nums[j])<br>                dp[i] += dp[i-nums[j]];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[target];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>背包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>518. 零钱兑换 II</title>
    <link href="/2021/08/10/518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-II/"/>
    <url>/2021/08/10/518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-II/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/coin-change-2/">518. 零钱兑换 II - 力扣（LeetCode）</a></p><p><img src="/2021/08/10/518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-II/image-20210810231332729.png" alt="image-20210810231332729"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>完全背包问题，物品是无限的。也就是说不用像01背包那样，背包容量得从大到小遍历，保证每个物品被添加一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.size(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>    dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而完全背包问题，可以正序；背包在外 物品在内其实也可以，因为dp [j]要依赖前面的，可以保证前面的是计算的</p><p>遍历物品在外层循环，遍历背包容量在内层循环：</p><p><img src="/2021/08/10/518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-II/image-20210810231631589.png" alt="image-20210810231631589"></p><p>遍历背包容量在外层循环，遍历物品在内层循环：（从上到下）</p><p><img src="/2021/08/10/518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-II/image-20210810231857341.png" alt="image-20210810231857341"></p><h3 id="递推五部曲"><a href="#递推五部曲" class="headerlink" title="递推五部曲"></a>递推五部曲</h3><p>1、dp数组和下标定义</p><p>​    dp [j] 总金额为j的货币组合数dp [j]</p><p>2、递推公式</p><p>​    dp[j] （考虑coins[i]的组合总和） 就是所有的dp[j - coins[i]]（不考虑coins[i]）相加。</p><p>​    dp[j] += dp[j - coins[i]];</p><p>3、dp数组初始化</p><p>​    dp[0]要为1，凑成总⾦额0的货币组合数为1。</p><p>4、遍历顺序</p><p>​    硬币在外，金钱总额在内；这样是组合数{1,5}，不会出现{5,1}</p><p>​    金钱总额在外，硬币在内；这样是排列数{1,5} {5,1}，因为硬币在内，两种情况都会计算</p><p>5、举例</p><p> amount = 5, coins = [1, 2, 5]</p><p>只有coins[0]这枚硬币，组合只有1种；</p><p>有两枚硬币，背包为2的时候，有1+1，0+2两种；</p><p><img src="/2021/08/10/518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-II/image-20210810233901382.png" alt="image-20210810233901382"></p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount, <span class="hljs-keyword">int</span>[] coins)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[amount + <span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; coins.length; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = coins[i]; j &lt; amount+<span class="hljs-number">1</span>; j++) &#123;<br>            dp[j] += dp[j-coins[i]];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[amount];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>背包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>376. 摆动序列</title>
    <link href="/2021/08/09/376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/"/>
    <url>/2021/08/09/376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/wiggle-subsequence/">376. 摆动序列 - 力扣（LeetCode）</a></p><p><img src="/2021/08/09/376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/image-20210809235215867.png" alt="image-20210809235215867"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>前一个差值 和 后一个差值不一样；</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.length &lt;= <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> nums.length;<br><br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>; <span class="hljs-comment">//默认最右边已有一个山峰</span><br>    <span class="hljs-keyword">int</span> preDiff = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123; <span class="hljs-comment">//保证左边肯定有</span><br>        <span class="hljs-keyword">int</span> curDiff = nums[i] - nums[i - <span class="hljs-number">1</span>]; <span class="hljs-comment">//当前差值</span><br>        <span class="hljs-keyword">if</span> ((curDiff&gt;<span class="hljs-number">0</span> &amp;&amp; preDiff&lt;=<span class="hljs-number">0</span>) || (curDiff&lt;<span class="hljs-number">0</span> &amp;&amp; preDiff&gt;=<span class="hljs-number">0</span>))&#123;<br>            count++;<br>            preDiff = curDiff;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>455. 分发饼干</title>
    <link href="/2021/08/05/455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/"/>
    <url>/2021/08/05/455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/assign-cookies/">455. 分发饼干 - 力扣（LeetCode）</a></p><p><img src="/2021/08/05/455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/image-20210805230332025.png" alt="image-20210805230332025"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>贪心<br>          小饼干给胃口小的孩子；如果饼干不够大，换大的饼干给这个孩子。</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    贪心</span><br><span class="hljs-comment">      小饼干 分给胃口小的孩子</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] g, <span class="hljs-keyword">int</span>[] s)</span> </span>&#123;<br>    <span class="hljs-comment">//s是饼干size，g是小孩胃口</span><br>    Arrays.sort(g);<br>    Arrays.sort(s);<br>    <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>; <span class="hljs-comment">//满足的小孩索引</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (idx &lt; g.length &amp;&amp; g[idx] &lt;= s[i])&#123;<br>            <span class="hljs-comment">// idx块饼干，满足第i个孩子</span><br>            idx++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> idx;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指】63. 股票的最大利润</title>
    <link href="/2021/08/03/%E3%80%90%E5%89%91%E6%8C%87%E3%80%9163-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/"/>
    <url>/2021/08/03/%E3%80%90%E5%89%91%E6%8C%87%E3%80%9163-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">剑指 Offer 63. 股票的最大利润 - 力扣（LeetCode）</a></p><p><img src="/2021/08/03/%E3%80%90%E5%89%91%E6%8C%87%E3%80%9163-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/image-20210803235852522.png" alt="image-20210803235852522"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(prices.length == <span class="hljs-number">0</span> || prices == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[prices.length];<br>    <span class="hljs-keyword">int</span> min = prices[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; dp.length; i++) &#123;<br>        min = Math.min(min, prices[i]);<br>        dp[i] = Math.max(dp[i-<span class="hljs-number">1</span>], prices[i] - min);<br>    &#125;<br>    <span class="hljs-comment">// dp数组最大值</span><br>    <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dp.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (max &lt; dp[i])<br>            max = dp[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>剑指</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指】49. 丑数</title>
    <link href="/2021/08/02/%E3%80%90%E5%89%91%E6%8C%87%E3%80%9149-%E4%B8%91%E6%95%B0/"/>
    <url>/2021/08/02/%E3%80%90%E5%89%91%E6%8C%87%E3%80%9149-%E4%B8%91%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/chou-shu-lcof/">剑指 Offer 49. 丑数 - 力扣（LeetCode）</a></p><p><img src="/2021/08/02/%E3%80%90%E5%89%91%E6%8C%87%E3%80%9149-%E4%B8%91%E6%95%B0/image-20210802233852443.png" alt="image-20210802233852443"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1、维护一个最小堆，下一个最小值就是堆顶元素。同时需要维护一个set，避免重复元素的加入。</p><p>2、动态规划</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] nums = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>&#125;;<br>    HashSet&lt;Long&gt; seen = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(); <span class="hljs-comment">// 去重</span><br>    PriorityQueue&lt;Long&gt; heap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();<br>    seen.add(<span class="hljs-number">1L</span>);<br>    heap.offer(<span class="hljs-number">1L</span>);<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">long</span> min = heap.poll(); <span class="hljs-comment">//弹出当前堆中 最小的</span><br>        res = (<span class="hljs-keyword">int</span>) min;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">long</span> tmp = num * min;<br>            <span class="hljs-keyword">if</span> (!seen.contains(tmp))&#123;<br>                seen.add(tmp); <span class="hljs-comment">//没有出现过，就添加</span><br>                heap.offer(tmp);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>剑指</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指】47. 礼物的最大价值</title>
    <link href="/2021/08/02/%E3%80%90%E5%89%91%E6%8C%87%E3%80%9147-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/"/>
    <url>/2021/08/02/%E3%80%90%E5%89%91%E6%8C%87%E3%80%9147-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">剑指 Offer 47. 礼物的最大价值 - 力扣（LeetCode）</a></p><p><img src="/2021/08/02/%E3%80%90%E5%89%91%E6%8C%87%E3%80%9147-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/image-20210802230424698.png" alt="image-20210802230424698"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>和题64. 最小路径和差不多，路径上选择最大价值的路径</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p>一开始递推公式搞错了，没有加上grid [i] [j]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">            1.dp[i][j]  i j位置价值最大的路径</span><br><span class="hljs-comment">            2.递推公式 到达方式就两种，左边 上边过来的，选择较大的；还要加上当前路径的价值</span><br><span class="hljs-comment">            3.第一行 第一列，都是相加</span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-keyword">int</span> m = grid.length; <span class="hljs-comment">//行</span><br>    <span class="hljs-keyword">int</span> n = grid[<span class="hljs-number">0</span>].length; <span class="hljs-comment">//列</span><br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        sum += grid[<span class="hljs-number">0</span>][i];<br>        dp[<span class="hljs-number">0</span>][i] = sum;<br>    &#125;<br>    sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        sum += grid[i][<span class="hljs-number">0</span>];<br>        dp[i][<span class="hljs-number">0</span>] = sum;<br>    &#125;<br><br>    <span class="hljs-comment">// 递推</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            dp[i][j] = grid[i][j] + Math.max(dp[i-<span class="hljs-number">1</span>][j], dp[i][j-<span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>剑指</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>494. 目标和</title>
    <link href="/2021/08/01/494-%E7%9B%AE%E6%A0%87%E5%92%8C/"/>
    <url>/2021/08/01/494-%E7%9B%AE%E6%A0%87%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/target-sum/">494. 目标和 - 力扣（LeetCode）</a></p><p><img src="/2021/08/01/494-%E7%9B%AE%E6%A0%87%E5%92%8C/image-20210801233656727.png" alt="image-20210801233656727"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1、直观思路，回溯，暴力搜索</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">就像二叉树的遍历DFS、看过的二叉树的递归逻辑<br>1.确定递推返回值和参数<br>2.终止条件<br>3.单层遍历逻辑<br></code></pre></td></tr></table></figure><p>2、动态规划</p><p>和石子均分两堆差不多，+号一堆，-号一堆，如果总重量分别是x、y的话，那么</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">x</span>+y <span class="hljs-operator">=</span> sum<br><span class="hljs-keyword">x</span>-y <span class="hljs-operator">=</span> <span class="hljs-keyword">target</span><br></code></pre></td></tr></table></figure><p>就可以知道x = (sum+target)/2，容量为x的背包，能否填满。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs inform7">1.确定dp数组以及下标的含义<br>dp<span class="hljs-comment">[j]</span> 表示：填满j（包括j）这么⼤容积的包，有dp<span class="hljs-comment">[j]</span>种⽅法<br>2.确定递推公式 有哪些来源能达到dp<span class="hljs-comment">[j]</span><br>在不考虑nums<span class="hljs-comment">[i]</span>，容量j-num<span class="hljs-comment">[i]</span>，有dp<span class="hljs-comment">[j - nums<span class="hljs-comment">[i]</span>]</span>中⽅法。<br>弄上nums<span class="hljs-comment">[i]</span>，就多了dp<span class="hljs-comment">[j - nums<span class="hljs-comment">[i]</span>]</span>中方法；（新增了一个方法）<br>因此，dp<span class="hljs-comment">[j]</span> += dp<span class="hljs-comment">[j - nums<span class="hljs-comment">[i]</span>]</span>，组合类的问题，累加起来<br>3.初始化<br>dp<span class="hljs-comment">[0]</span>要初始化为1，不然全是0了。<br>4.遍历顺序<br>滚动数组，商品nums在外面，里面target背包容量。<br>5.举例<br>输⼊： nums: <span class="hljs-comment">[1, 1, 1, 1, 1]</span>, S: 3<br>bagSize = (S + sum) / 2 = (3 + 5) / 2 = 4<br></code></pre></td></tr></table></figure><p>这里的举例，要<strong>好好看</strong>。</p><p><img src="/2021/08/01/494-%E7%9B%AE%E6%A0%87%E5%92%8C/image-20210802000434931.png" alt="image-20210802000434931"></p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    dfs(nums,<span class="hljs-number">0</span>,target, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">        直观思路，回溯暴力搜索；</span><br><span class="hljs-comment">        就像二叉树的遍历DFS、看过的二叉树的递归逻辑</span><br><span class="hljs-comment">        1.确定递推返回值和参数</span><br><span class="hljs-comment">        2.终止条件</span><br><span class="hljs-comment">        3.单层遍历逻辑</span><br><span class="hljs-comment">     */</span><br><br><span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">//记录总共的方案数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span> sum)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (start == nums.length)&#123;<br>        <span class="hljs-comment">// 终止条件，每一个数都做出了 +/- 的抉择</span><br>        <span class="hljs-keyword">if</span> (sum == target)&#123;<br>            <span class="hljs-comment">//刚好满足</span><br>            count++;<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 选择列表，sum的+/-</span><br>    dfs(nums, start+<span class="hljs-number">1</span>, target, sum+nums[start]);<br>    dfs(nums, start+<span class="hljs-number">1</span>, target, sum-nums[start]);<br>&#125;<br></code></pre></td></tr></table></figure><p>宫水三叶的这种写法， 有点像刷《二叉树》专题的递归思路。</p><p>先假想dfs的作用（子树的总数），遍历左子树、右子树，</p><p><img src="/2021/08/01/494-%E7%9B%AE%E6%A0%87%E5%92%8C/image-20210801233854366.png" alt="image-20210801233854366"></p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findTargetSumWays2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        sum += nums[i];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (target &gt; sum)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> ((target+sum) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>        <span class="hljs-comment">// 左堆小数，不可能</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> bagSize = (target+sum)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[bagSize + <span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = bagSize; j &gt;= nums[i]; j--) &#123;<br>            dp[j] += dp[j - nums[i]];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[bagSize]; <span class="hljs-comment">// 凑成左堆的方法数。</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1049. 最后一块石头的重量 II</title>
    <link href="/2021/08/01/1049-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F-II/"/>
    <url>/2021/08/01/1049-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F-II/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/last-stone-weight-ii/">1049. 最后一块石头的重量 II - 力扣（LeetCode）</a></p><p><img src="/2021/08/01/1049-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F-II/image-20210801232052170.png" alt="image-20210801232052170"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>和<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集 - 力扣（LeetCode）</a>思路差不多。</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">        递归，将石子分成重量相差不多的两堆即可，相减即可。</span><br><span class="hljs-comment">        背包容量为target，看最多能塞多少重量石头；</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastStoneWeightII</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] stones)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; stones.length; i++) &#123;<br>        sum += stones[i];<br>    &#125;<br>    <span class="hljs-keyword">int</span> target = sum / <span class="hljs-number">2</span>; <span class="hljs-comment">//一半石头的重量，如果是奇数，一定是较小的那个。 3/2=1</span><br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">30</span> * <span class="hljs-number">100</span> / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>]; <span class="hljs-comment">//一半重量</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; stones.length; i++) &#123;<br>        <span class="hljs-comment">// 遍历一个个物品装包</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = target; j &gt;= stones[i]; j--) &#123;<br>            dp[j] = Math.max(dp[j], dp[j-stones[i]] + stones[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//分成两堆⽯头，⼀堆⽯头的总重量是dp[target]，另⼀堆就是sum - dp[target]。</span><br>    <span class="hljs-keyword">return</span> sum - dp[target] - dp[target];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>背包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>77. 组合</title>
    <link href="/2021/07/28/77-%E7%BB%84%E5%90%88/"/>
    <url>/2021/07/28/77-%E7%BB%84%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/combinations/">77. 组合 - 力扣（LeetCode）</a></p><p><img src="/2021/07/28/77-%E7%BB%84%E5%90%88/image-20210728090847936.png" alt="image-20210728090847936"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p><a href="https://leetcode-cn.com/problems/combinations/solution/dai-ma-sui-xiang-lu-dai-ni-xue-tou-hui-s-0uql/">「代码随想录」带你学透回溯算法！【77. 组合】 - 组合 - 力扣（LeetCode）</a></p></blockquote><p>回溯模板</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">backtracking</span>(<span class="hljs-params">参数</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        backtracking(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>1、确定递归函数的返回值和参数</p><p>​    递归函数中必须要有的两个参数n、k，因为是从集合n中取出k个数；</p><p>​    每次取数后，选择列表就在收缩。</p><p>​    （由于定义了全局变量path和res，就不放在递归函数参数里了）</p><p><img src="/2021/07/28/77-%E7%BB%84%E5%90%88/image-20210728092311924.png" alt="image-20210728092311924"></p><p>2、终止条件</p><p>​    path路径长度 达到了要求k，就跳出</p><p>3、单层搜索的过程</p><p><img src="/2021/07/28/77-%E7%BB%84%E5%90%88/image-20210728092514318.png" alt="image-20210728092514318"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = startIndex; i &lt;= n; i++) &#123; <span class="hljs-comment">// 控制树的横向遍历</span><br>    path.push_back(i); <span class="hljs-comment">// 处理节点 </span><br>    backtracking(n, k, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 递归：控制树的纵向遍历，注意下一层搜索要从i+1开始</span><br>    path.pop_back(); <span class="hljs-comment">// 回溯，撤销处理的节点</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;(); <span class="hljs-comment">//存储最后结果</span><br>LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;(); <span class="hljs-comment">//存储每一条路径</span><br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k) &#123;<br>    backtrack(n,k,<span class="hljs-number">1</span>); <span class="hljs-comment">// 选择列表从1开始</span><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    k为二叉树的深度（回溯深度）</span><br><span class="hljs-comment">    n为二叉树的广度（选择列表有多少）</span><br><span class="hljs-comment">    startIndex为选择列表的开始</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> startIndex)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (path.size() == k)&#123;<br>        <span class="hljs-comment">// 满足输出条件</span><br>        res.add(<span class="hljs-keyword">new</span> LinkedList&lt;&gt;(path));<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = startIndex; i &lt;= n; i++) &#123; <span class="hljs-comment">//控制树的横向遍历，选择列表</span><br>        path.add(i); <span class="hljs-comment">// 做出选择</span><br>        backtrack(n, k, i+<span class="hljs-number">1</span>); <span class="hljs-comment">// 递归：控制树的纵向遍历，注意下一层搜索要从i+1开始</span><br>        path.removeLast(); <span class="hljs-comment">//撤销选择</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>416. 分割等和子集</title>
    <link href="/2021/07/27/416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/"/>
    <url>/2021/07/27/416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集 - 力扣（LeetCode）</a></p><p><img src="/2021/07/27/416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/image-20210727233028058.png" alt="image-20210727233028058"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1、回溯来做，每次选择一个数，再撤销；这样不断创建两个子集（已选择的数、未选择的数，看是否相等）</p><p>​    <a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/dong-tai-gui-hua-hui-su-qiong-ju-zi-ji-c-9vhk/">动态规划，回溯穷举子集超时间 - 分割等和子集 - 力扣（LeetCode）</a></p><p>2、01背包的做法</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vim">题目可以变为：背包体积为sum/<span class="hljs-number">2</span>，如果nums中有元素能填满sum/<span class="hljs-number">2</span>，<br>也就是说这些元素的和为sum/<span class="hljs-number">2</span>，剩下的元素就是sum/<span class="hljs-number">2</span><br><br><span class="hljs-number">1</span>.<span class="hljs-keyword">dp</span>数组定义，<span class="hljs-keyword">dp</span>[<span class="hljs-keyword">j</span>]，容量为<span class="hljs-keyword">j</span>的背包，能容纳的最大容量<br><span class="hljs-number">2</span>.递归公式 <span class="hljs-keyword">dp</span>[<span class="hljs-keyword">j</span>] = <span class="hljs-built_in">max</span>(<span class="hljs-keyword">dp</span>[<span class="hljs-keyword">j</span>], <span class="hljs-keyword">dp</span>[<span class="hljs-keyword">j</span>-nums[i]] + nums[i])<br><span class="hljs-number">3</span>.初始化<br><span class="hljs-number">4</span>.遍历顺讯<br><span class="hljs-number">5</span>.举例<span class="hljs-keyword">dp</span>数组<br></code></pre></td></tr></table></figure><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><h3 id="01背包做法"><a href="#01背包做法" class="headerlink" title="01背包做法"></a>01背包做法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-comment">// 背包容量最大为20000；元素最大200，nums长度最大100；</span><br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10001</span>];<br>    <span class="hljs-comment">// 求和</span><br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        sum += nums[i];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">//不能被2整除</span><br><br>    <span class="hljs-keyword">int</span> target = sum / <span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">// dp的遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = target; j &gt;= nums[i]; j--) &#123;<br>            dp[j] = Math.max(dp[j], dp[j-nums[i]] + nums[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dp[target] == target)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>; <span class="hljs-comment">//如果背包容量为sum/2，则刚好有元素和 等于 sum/2</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>2021年7月27日23:32:48</p><p>​    明天再补，困了。。。。</p><p>2021年7月28日23:45:08</p><p>​    emm，这个版本没有记忆化 剪枝，但是思路就是这样。</p><h4 id="回溯中间元素-重复被选择的问题"><a href="#回溯中间元素-重复被选择的问题" class="headerlink" title="回溯中间元素 重复被选择的问题"></a>回溯中间元素 重复被选择的问题</h4><p>例如{1,2,5}，对于下面的逻辑，startIndex为0的时候，都正常，输出</p><p>[1, 2, 5]<br>[1, 2]<br>[1, 5]<br>[1]</p><p>当第一个元素遍历完，i++，i变为1，list添加了元素2，backbrack递归传入startIndex为1，又添加了元素2，因此输出</p><p>[2, 2]<br>[2, 5]<br>[2]</p><p>当第二个元素遍历完，i++，i变为2，输出</p><p>[5]</p><p><img src="/2021/07/27/416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/image-20210728235508485.png" alt="image-20210728235508485"></p><h4 id="题解代码"><a href="#题解代码" class="headerlink" title="题解代码"></a>题解代码</h4><p>有一个isUsed避免元素被重复添加的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 第二种解法，回溯 所有的子集</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canPartition2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        sum += nums[i];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (sum%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">//总和为奇数，肯定不行</span><br><br>    target = sum/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">boolean</span>[] isUsed = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[nums.length];<br>    backbrack(nums, isUsed, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    回溯</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">boolean</span> res = <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">int</span> target = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backbrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">boolean</span>[] isUsed, <span class="hljs-keyword">int</span> startIndex, <span class="hljs-keyword">int</span> sum, List&lt;Integer&gt; list)</span></span>&#123;<br>    <span class="hljs-comment">// 终止条件</span><br>    <span class="hljs-keyword">if</span> (sum &gt; target)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (sum == target)&#123;<br>        res = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//开始横向遍历 选择列表</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = startIndex; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (isUsed[i])<br>            <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//使用过，就跳过</span><br>        sum += nums[i];<br>        list.add(nums[i]);<br>        isUsed[i] = <span class="hljs-keyword">true</span>; <span class="hljs-comment">//防止被重复选择</span><br>        backbrack(nums, isUsed, startIndex+<span class="hljs-number">1</span>, sum, list);<br>        <span class="hljs-comment">// 撤销选择</span><br>        System.out.println(list.toString());<br>        sum -= list.get(list.size() - <span class="hljs-number">1</span>);<br>        list.remove(list.size() - <span class="hljs-number">1</span>); <span class="hljs-comment">//减去最后一个 并list去除最后一个；</span><br>        isUsed[i] = <span class="hljs-keyword">false</span>; <span class="hljs-comment">//防止被重复选择</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs text">测试用例，取消注释sout<br>public static void main(String[] args) &#123;<br>    c416_canPartition partition = new c416_canPartition();<br>    boolean b = partition.canPartition2(new int[]&#123;1, 2, 4, 5&#125;);<br>    System.out.println(b);<br>&#125;<br><br>不会有重复消费的<br>[1, 2, 4]<br>[1, 2, 5]<br>[1, 2]<br>[1, 4, 5]<br>[1, 4]<br>[1, 5]<br>[1]<br>[2, 4]<br>[2, 5]<br>[2]<br>[4, 2]<br>[4, 5]<br>[4]<br>[5, 2]<br>[5, 4]<br>[5]<br>true<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>背包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>轮播图 后端实现</title>
    <link href="/2021/07/25/%E8%BD%AE%E6%92%AD%E5%9B%BE-%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/07/25/%E8%BD%AE%E6%92%AD%E5%9B%BE-%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>参考</p><blockquote><p>代码来源：<a href="https://github.com/zq99299/foodie-dev">https://github.com/zq99299/foodie-dev</a></p><p>设计：<a href="https://juejin.cn/post/6911691777657454599">banner轮播图业务的简单设计与思考</a></p><p>后台管理：<a href="http://www.woshipm.com/pd/3511023.html">广告位（banner）的可视化管理后台逻辑说明 | 人人都是产品经理</a></p></blockquote><p>表结构：</p><ul><li>商品id和商品分类id，用于用户点击后，会去什么页面</li></ul><p><img src="/2021/07/25/%E8%BD%AE%E6%92%AD%E5%9B%BE-%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0/image-20210725170838732.png" alt="image-20210725170838732"></p><h3 id="后端代码"><a href="#后端代码" class="headerlink" title="后端代码"></a>后端代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CarouselServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CarouselService</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> CarouselMapper carouselMapper;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Carousel&gt; <span class="hljs-title">queryAll</span><span class="hljs-params">(Integer isShow)</span> </span>&#123;<br>        Example example = <span class="hljs-keyword">new</span> Example(Carousel.class);<br>        example.orderBy(<span class="hljs-string">&quot;sort&quot;</span>).desc();<br>        Example.Criteria criteria = example.createCriteria();<br>        criteria.andEqualTo(<span class="hljs-string">&quot;isShow&quot;</span>, isShow);<br>        List&lt;Carousel&gt; carousels = carouselMapper.selectByExample(example);<br>        <span class="hljs-keyword">return</span> carousels;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>controller层</p><p>​    加入缓存系统，保存并发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> CarouselService carouselService;<br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RedisOperator redisOperator;<br><br><span class="hljs-meta">@ApiOperation(value = &quot;获取首页轮播图列表&quot;)</span><br><span class="hljs-meta">@GetMapping(&quot;/carousel&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> JSONResult <span class="hljs-title">carousel</span><span class="hljs-params">()</span> </span>&#123;<br>    String carouselStr = redisOperator.get(<span class="hljs-string">&quot;carousel&quot;</span>);<br>    List&lt;Carousel&gt; carousels = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">// 如果 redis 中没有，则去数据库中获取</span><br>    <span class="hljs-keyword">if</span> (StringUtils.isBlank(carouselStr)) &#123;<br>        carousels = carouselService.queryAll(YesOrNo.YES.type);<br>        <span class="hljs-comment">// 并且将数据缓存到 redis 中</span><br>        redisOperator.set(<span class="hljs-string">&quot;carousel&quot;</span>, JsonUtils.objectToJson(carousels));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 否则，直接从反序列化</span><br>        carousels = JsonUtils.jsonToList(carouselStr, Carousel.class);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> JSONResult.ok(carousels);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;banner&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;top: 213px;&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--轮播 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;am-slider am-slider-default scoll&quot;</span> <span class="hljs-attr">data-am-flexslider</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;demo-slider-0&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;am-slides&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;banner1&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;clear&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs html">renderCarousel() &#123;<br>var serverUrl = app.serverUrl;<br>// 获得轮播图<br>axios.get(<br>serverUrl + &#x27;/index/carousel&#x27;, &#123;&#125;)<br>.then(res =&gt; &#123;<br>if (res.data.status == 200) &#123;<br>var carouselList = res.data.data<br>this.carouselList = carouselList;<br><br><br>// 循环渲染轮播图<br>var $slider = $(&#x27;#demo-slider-0&#x27;);<br>for (var i = 0; i &lt; carouselList.length; i++) &#123;<br><br>                                        var type = carouselList[i].type;<br>                                        var catId = carouselList[i].catId;<br>                                        var itemId = carouselList[i].itemId;<br>                                        var catOrItemId = &quot;&quot;;<br><br>                                        if (type == 1) &#123;<br>                                        catOrItemId = itemId;<br>                                        &#125;<br>                                        if (type == 2) &#123;<br>                                        catOrItemId = catId;<br>                                        &#125;<br><br>                                        catOrItemId = encodeURI(catOrItemId);<br><br>                                        var cal = &#x27;<span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background: &#x27; + carouselList[i].backgroundColor +</span></span><br><span class="hljs-string"><span class="hljs-tag">                                        &#x27;;&quot;</span>&gt;</span>&#x27; +<br>                                        &#x27;<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">javascript:showPage(</span>&#x27; + <span class="hljs-attr">type</span> + &#x27;,\&quot;&#x27;+<span class="hljs-attr">catOrItemId</span>+&#x27;\&quot;);&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;&#x27; + carouselList[i].imageUrl + &#x27;&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>&#x27; +<br>                                        +&#x27;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>&#x27;;<br>                                        $slider.flexslider(&#x27;addSlide&#x27;, cal);<br>                                        &#125;<br>                                        // <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;banner4&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;images/ad4.jpg&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><br>// console.log($slider.flexslider(&#x27;count&#x27;));<br>$slider.flexslider(&#x27;removeSlide&#x27;, 0);<br><br>// var img1 = &#x27;<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://122.152.205.72:88/group1/M00/00/02/CpoxxFvJanCAMgx0AAU6szwbghI657.png&quot;</span> /&gt;</span>&#x27;;<br>    // $slider.flexslider(&#x27;addSlide&#x27;, img1);<br>    &#125;<br>    &#125;);<br>    &#125;,<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>75. 颜色分类</title>
    <link href="/2021/07/20/75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/"/>
    <url>/2021/07/20/75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/sort-colors/">75. 颜色分类 - 力扣（LeetCode）</a></p><p><img src="/2021/07/20/75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/image-20210724234056779.png" alt="image-20210724234056779"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1、统计颜色的各个频次即可。</p><p>2、也可以两次遍历，0放前面，2放后面；1就自己在中间了；</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> s1 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> s2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> s3 = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>        <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span>)<br>            s1++;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num == <span class="hljs-number">1</span>)<br>            s2++;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num == <span class="hljs-number">2</span>)<br>            s3++;<br>    &#125;<br>    <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>; <span class="hljs-comment">// 索引</span><br>    <span class="hljs-keyword">while</span> (--s1 &gt;= <span class="hljs-number">0</span>)<br>        nums[idx++] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (--s2 &gt;= <span class="hljs-number">0</span>)<br>        nums[idx++] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (--s3 &gt;= <span class="hljs-number">0</span>)<br>        nums[idx++] = <span class="hljs-number">2</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>64. 最小路径和</title>
    <link href="/2021/07/20/64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <url>/2021/07/20/64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/minimum-path-sum/">64. 最小路径和 - 力扣（LeetCode）</a></p><p><img src="/2021/07/20/64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/image-20210724232540859.png" alt="image-20210724232540859"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.确定dp数组以及下标的含义</p><blockquote><p>dp[i] [j]表示 走到i j位置的最小路径和</p></blockquote><p>2.确定递推公式</p><blockquote><p>dp[i] [j]可以有两种方式到达，向下移动、向右移动即dp[i-1] [j] 、 dp[i] [ j-1]，选择两种方式中较小的方式</p><p>因此dp[i] [j] = min(dp[i-1] [j] + dp[i] [j-1]) + dp[i] [j]</p></blockquote><p>3.dp数组初始化</p><blockquote><p>上边界 和 左边界，最小的路径，一定是直着走，如果绕弯就会多出其他路径。</p></blockquote><p>4.确定遍历顺序</p><blockquote><p>从上到下 从左到右遍历</p></blockquote><p>5.举例推导dp数组</p><blockquote></blockquote><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> m = grid.length; <span class="hljs-comment">// 行</span><br>    <span class="hljs-keyword">int</span> n = grid[<span class="hljs-number">0</span>].length; <span class="hljs-comment">// 列</span><br><br>    <span class="hljs-comment">// dp数组初始化，dp(i,j)表示到达位置i j的最小路径和</span><br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br>    <span class="hljs-comment">// 初始化第一行 最小路径和肯定是第一行直着走</span><br>    <span class="hljs-keyword">int</span> pre = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        dp[<span class="hljs-number">0</span>][i] = pre + grid[<span class="hljs-number">0</span>][i];<br>        pre = dp[<span class="hljs-number">0</span>][i];<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化第一列</span><br>    pre = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        dp[i][<span class="hljs-number">0</span>] = pre + grid[i][<span class="hljs-number">0</span>];<br>        pre = dp[i][<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-comment">// 递推公式：达到(i,j)可以由两种情况到达 (i-1,j) (i,j-1)</span><br>    <span class="hljs-comment">// 两种情况中取min，然后+当前路径数字即可。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            dp[i][j] = Math.min(dp[i-<span class="hljs-number">1</span>][j], dp[i][j-<span class="hljs-number">1</span>])  + grid[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>34. 在排序数组中查找元素的第一个和最后一个位置</title>
    <link href="/2021/07/20/34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/"/>
    <url>/2021/07/20/34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）</a></p><p><img src="/2021/07/20/34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/image-20210720231844588.png" alt="image-20210720231844588"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1、O(n)遍历即可</p><p>2、O(logn) 二分法查找，找到后，再确定左右边界</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] searchRange(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>    <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> mid = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (target &gt; nums[mid])<br>            left = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &lt; nums[mid])<br>            right = mid - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 相等的时候，左右寻找边界</span><br>            <span class="hljs-keyword">int</span> tmp = mid;<br>            <span class="hljs-keyword">while</span> (nums[tmp] == target)&#123;<br>                tmp--;<br>                <span class="hljs-keyword">if</span> (tmp &lt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            tmp++; <span class="hljs-comment">//++就是相等的那个了</span><br>            <span class="hljs-keyword">while</span> (nums[mid] == target)&#123;<br>                mid++;<br>                <span class="hljs-keyword">if</span> (mid &gt;= nums.length)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            mid--;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;tmp,mid&#125;;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>343. 整数拆分</title>
    <link href="/2021/07/18/343-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/"/>
    <url>/2021/07/18/343-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/integer-break/">343. 整数拆分 - 力扣（LeetCode）</a></p><p><img src="/2021/07/18/343-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/image-20210718220313427.png" alt="image-20210718220313427"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>问题是包含子问题的，要i拆分后乘积最大，比如拆分后有j，那么i乘积最大 一定包含j乘积最大 这个子问题；</p><p>方法论：代码随想录</p><p>1.确定dp数组以及下标的含义</p><blockquote><p>dp[i]为 数字i拆分后 乘积最大的值</p></blockquote><p>2.确定递推公式</p><blockquote><p>dp[i]最大乘积，拆分的时候，遍历1到j</p><ul><li>拆分出j，直接进行相乘 i-j * j</li><li>拆分出j，将剩下的i-j进行拆分后相乘 j * dp(i-j)</li></ul><p>因此dp[i] = max(dp[i], max((i - j) <em> j, dp[i - j] </em> j  ))</p></blockquote><p>3.dp数组初始化</p><blockquote><p>问题中n是从2开始的，dp(2)的时候需要dp(1)，因此dp(1)=1</p><p>虽然这不满足dp的定义</p></blockquote><p>4.确定遍历顺序</p><blockquote><p>i从前到后遍历</p></blockquote><p>5.举例推导dp数组</p><blockquote><p>2, max(0, max(1,1))</p></blockquote><p>注意从1-j遍历的时候，要比较是现在的乘积大，还是之前的dp[i]乘积大。</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// dp[i] 表示拆分i的最大乘积</span><br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; n+<span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++) &#123;<br>            <span class="hljs-comment">// 从j=1开始拆分 或者 不拆分，看哪个比较大</span><br>            dp[i] = Math.max(dp[i], Math.max(j * (i-j), j * dp[i-j]));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>63. 不同路径 II</title>
    <link href="/2021/07/18/63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-II/"/>
    <url>/2021/07/18/63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-II/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/unique-paths-ii/">63. 不同路径 II - 力扣（LeetCode）</a></p><p><img src="/2021/07/18/63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-II/image-20210718202709033.png" alt="image-20210718202709033"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>和62题 不同路径一样，只是添加了障碍物，</p><p>在dp数组初始化 和 dp遍历的时候，关注有障碍物的情况即可。</p><ul><li>dp初始化的时候，在第一行、第一列的时候，有障碍物后面都是0；</li><li>dp遍历的时候，有障碍物 dp应该为0；</li></ul><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] obstacleGrid)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> m = obstacleGrid.length; <span class="hljs-comment">// 行</span><br>    <span class="hljs-keyword">int</span> n = obstacleGrid[<span class="hljs-number">0</span>].length; <span class="hljs-comment">// 列</span><br><br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br>    <span class="hljs-comment">// dp数组初始化，第一行、第一列都是1;</span><br>    <span class="hljs-comment">// 边边上面，有障碍前面才是1</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-comment">// 有障碍</span><br>        <span class="hljs-keyword">if</span> (obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">break</span>;<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][i] == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">break</span>;<br>        dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 从上到下、从左到右遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] + dp[i][j-<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                dp[i][j] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 有障碍就不管了</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>62. 不同路径</title>
    <link href="/2021/07/18/62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
    <url>/2021/07/18/62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/unique-paths/">62. 不同路径 - 力扣（LeetCode）</a></p><p><img src="/2021/07/18/62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/image-20210718180658104.png" alt="image-20210718180658104"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>也可以递归的写，但是会超时</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (i &gt; m || j &gt; n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 越界了</span><br><span class="hljs-keyword">if</span> (i == m &amp;&amp; j == n) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 找到⼀种⽅法，相当于找到了叶⼦节点</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(i + <span class="hljs-number">1</span>, j, m, n) + <span class="hljs-built_in">dfs</span>(i, j + <span class="hljs-number">1</span>, m, n);<br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, m, n);<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>方法论：代码随想录</p><p>1.确定dp数组以及下标的含义</p><blockquote><p>dp[i] [j]表示到i j位置有几种路径，ij表示格子的位置</p></blockquote><p>2.确定递推公式</p><blockquote><p>dp[i] [j]可以有两种方式到达，向下移动、向右移动即dp[i-1] [j] + dp[i] [ j-1]</p><p>因此dp[i] [j] = dp[i-1] [j] + dp[i] [j-1]</p></blockquote><p>3.dp数组初始化</p><blockquote><p>第一行、第一列的dp[i] [0]应该都为1，因为只有一条路径；</p></blockquote><p>4.确定遍历顺序</p><blockquote><p>从上到下 从左到右遍历</p></blockquote><p>5.举例推导dp数组</p><blockquote></blockquote><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br>    <span class="hljs-comment">// dp数组初始化，第一行、第一列都是1</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 从上到下、从左到右遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] + dp[i][j-<span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>53. 最大子序和</title>
    <link href="/2021/07/18/53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
    <url>/2021/07/18/53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子序和 - 力扣（LeetCode）</a></p><p><img src="/2021/07/18/53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/image-20210718165249781.png" alt="image-20210718165249781"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>方法论：代码随想录</p><p>1.确定dp数组以及下标的含义</p><blockquote><p>dp[i]为 [0,i]下标的最大连续子序和</p></blockquote><p>2.确定递推公式</p><blockquote><p>dp[i]可以有两种方式到达</p><ul><li>nums[i]是正数有增益、可以加入之前的子序列 dp[i-1] + nums[i]；</li><li>不加入前面的子序列，从头开始算子序列（前面dp为负，当前nums[i]为负）</li></ul><p>因此dp[i] = max(dp[i-1] + nums[i], nums[i])</p></blockquote><p>3.dp数组初始化</p><blockquote><p>只依赖于前一个dp[i-1]，要遍历，只需要将dp[0] = nums[0]</p></blockquote><p>4.确定遍历顺序</p><blockquote><p>从前到尾遍历接口</p></blockquote><p>5.举例推导dp数组</p><blockquote><p>例如cost为[-2,1,-3,4,-1,2,1,-5,4]，（4的时候，就从头开始计算子序列）</p><p>dp为[-2, 1, -2, 4, 3, 5, 6, 1, 5] </p></blockquote><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>    dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 初始化dp为nums本身</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; dp.length; i++) &#123;<br>        dp[i] = Math.max(nums[i], dp[i-<span class="hljs-number">1</span>] + nums[i]);<br>    &#125;<br>    <span class="hljs-comment">// System.out.println(Arrays.toString(dp));</span><br>    <span class="hljs-comment">// 寻找dp数组最大值</span><br>    <span class="hljs-keyword">int</span> max = Integer.MIN_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dp.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (max &lt; dp[i])<br>            max = dp[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>746. 使用最小花费爬楼梯</title>
    <link href="/2021/07/18/746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <url>/2021/07/18/746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯 - 力扣（LeetCode）</a></p><p><img src="/2021/07/18/746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/image-20210718162025030.png" alt="image-20210718162025030"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题的描述比较奇怪。</p><p>例子1：</p><p>可以理解为一开始站在cost为15的台阶，调到20后面的台阶。一开始站在15的台阶，花费体力为0，起跳到台阶顶才花费体力15；（<strong>关乎到dp数组的定义</strong>）我倾向这种</p><p>也可以理解为站在上面就花费了15体力，跳到台阶顶不花费体力。</p><p>方法论：代码随想录</p><p>1.确定dp数组以及下标的含义</p><blockquote><p>dp[i]为到达第i级台阶 最小的花费体力</p></blockquote><p>2.确定递推公式</p><blockquote><p>dp[i]可以有两种方式到达，跳一级台阶，跳两级台阶；</p><p>因此dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])</p></blockquote><p>3.dp数组初始化</p><blockquote><p>这个比较麻烦，一般初始化dp[0]和dp[1]即可；初始化为0，默认一开始不花费体力（因为本身就可以选择站在那，起跳后加上体力值）</p><p>例如cost为[10,15]，登顶花销应该是min(0+10, 0+15)</p></blockquote><p>4.确定遍历顺序</p><blockquote><p>从头到尾遍历接口</p></blockquote><p>5.举例推导dp数组</p><blockquote><p>例如cost为[10,15,20]，dp为[0, 0, 10, 15] （注意dp长一点，因为要登顶）</p></blockquote><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] cost)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (cost == <span class="hljs-keyword">null</span> || cost.length == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> len = cost.length;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len+<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; len+<span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-comment">// 下一步的花费，可以使跳一级台阶 也可以条二级台阶</span><br>        dp[i] = Math.min(dp[i-<span class="hljs-number">1</span>] + cost[i-<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">2</span>] + cost[i-<span class="hljs-number">2</span>]);<br>    &#125;<br>    <span class="hljs-comment">//        System.out.println(Arrays.toString(dp));</span><br>    <span class="hljs-keyword">return</span> dp[len];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指】68 - II. 二叉树的最近公共祖先</title>
    <link href="/2021/07/13/%E3%80%90%E5%89%91%E6%8C%87%E3%80%9168-II-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <url>/2021/07/13/%E3%80%90%E5%89%91%E6%8C%87%E3%80%9168-II-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - II. 二叉树的最近公共祖先 - 力扣（LeetCode）</a></p><p><img src="/2021/07/13/%E3%80%90%E5%89%91%E6%8C%87%E3%80%9168-II-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/image-20210713102255957.png" alt="image-20210713102255957"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>直观想法，从底部向上开始找，找到公共祖先返回即可。 </p><p>而<strong>后序遍历</strong>，就是从底向上的回溯过程。</p><p><strong>递归</strong>三部曲：</p><p>1.确定递归函数的参数 和 返回值</p><p>​    参数需要当前子树节点root、要找的p、q节点；返回值为最近的公共节点。如果遇到p、q节点，就返回p、q</p><p>2.终止条件</p><p>​    遇到空节点null、p、q节点，返回公共节点</p><p>3.单层的递归逻辑。</p><p>​    来源《代码随想录》</p><p><img src="/2021/07/13/%E3%80%90%E5%89%91%E6%8C%87%E3%80%9168-II-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/image-20210713102828089.png" alt="image-20210713102828089"></p><p>我们保留下left、right后进行情况判断：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-number">1</span>.左右都为<span class="hljs-literal">null</span>，返回<span class="hljs-literal">null</span>，当前子树 无祖先<br><span class="hljs-number">2</span>.左右都不为<span class="hljs-literal">null</span>，说明当前root为公共祖先<br><span class="hljs-number">3</span>.左为<span class="hljs-literal">null</span>，右不为<span class="hljs-literal">null</span>，返回右，（可能右就是祖先，也可能右只有p、q中一个节点）<br><span class="hljs-number">4</span>.右为<span class="hljs-literal">null</span>，左不为<span class="hljs-literal">null</span>，同理。<br></code></pre></td></tr></table></figure><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 假想已经有了最近公共祖先函数 lowestCommonAncestor</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;<br>    <span class="hljs-comment">// 2.终止条件；遇到null、遇到root==p/q时，返回公共节点</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span> || root == p || root == q)<br>        <span class="hljs-keyword">return</span> root;<br>    <span class="hljs-comment">// 3.单层的逻辑，看左右子树是否有p、q的公共祖先</span><br>    TreeNode left = lowestCommonAncestor(root.left, p, q);<br>    TreeNode right = lowestCommonAncestor(root.right, p, q);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        1.左右都为null，返回null，当前子树 无祖先</span><br><span class="hljs-comment">        2.左右都不为null，说明当前root为公共祖先</span><br><span class="hljs-comment">        3.左为null，右不为null，返回右，（可能右就是祖先，也可能右只有p、q中一个节点）</span><br><span class="hljs-comment">        4.右为null，左不为null，同理。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (left == <span class="hljs-keyword">null</span> &amp;&amp; right == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (left == <span class="hljs-keyword">null</span> &amp;&amp; right != <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> right;<br>    <span class="hljs-keyword">if</span> (left != <span class="hljs-keyword">null</span> &amp;&amp; right == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> left;<br>    <span class="hljs-keyword">return</span> root; <span class="hljs-comment">//1.左右都不为null</span><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
      <tag>dfs</tag>
      
      <tag>剑指</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>116. 填充每个节点的下一个右侧节点指针</title>
    <link href="/2021/07/10/116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/"/>
    <url>/2021/07/10/116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针 - 力扣（LeetCode）</a></p><p><img src="/2021/07/10/116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/image-20210710212934556.png" alt="image-20210710212934556"></p><p><img src="/2021/07/10/116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/image-20210710212941970.png" alt="image-20210710212941970"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1、bfs、层次遍历，取出每一层节点，挨个相连接即可</p><p>2、dfs、递归方式，对于前序遍历，对于这一层节点需要干什么；</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><h3 id="bfs-层次遍历"><a href="#bfs-层次遍历" class="headerlink" title="bfs 层次遍历"></a>bfs 层次遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. bfs、层次遍历；</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">connect</span><span class="hljs-params">(Node root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    Deque&lt;Node&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    q.offer(root);<br>    <span class="hljs-keyword">while</span> (!q.isEmpty()) &#123;<br>        <span class="hljs-keyword">int</span> size = q.size();<br>        <span class="hljs-comment">// 用于保存该层节点</span><br>        ArrayList&lt;Node&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            <span class="hljs-comment">// 遍历这一层的节点</span><br>            Node cur = q.poll();<br>            tmp.add(cur);<br>            <span class="hljs-comment">// 添加下一层节点</span><br>            <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-keyword">null</span>)<br>                q.offer(cur.left);<br>            <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-keyword">null</span>)<br>                q.offer(cur.right);<br>        &#125;<br>        <span class="hljs-comment">// 将该层节点，链接起来</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; tmp.size() - <span class="hljs-number">1</span>; i++) &#123;<br>            tmp.get(i).next = tmp.get(i + <span class="hljs-number">1</span>);<br>        &#125;<br>        tmp.get(tmp.size() - <span class="hljs-number">1</span>).next = <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="dfs-递归"><a href="#dfs-递归" class="headerlink" title="dfs - 递归"></a>dfs - 递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 2. 深度优先遍历，递归，对于前序遍历，对于这一层节点需要干什么；</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">connect2</span><span class="hljs-params">(Node root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    dfs(root.left, root.right);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><span class="hljs-comment">// 对于left、right两个节点，需要连接三条线</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Node left, Node right)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (left == <span class="hljs-keyword">null</span> || right == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span>;<br>    left.next = right; <span class="hljs-comment">//对于当前连接，仅需要连接既可</span><br>    <span class="hljs-comment">// 连接相同父节点的两个子节点</span><br>    dfs(left.left, left.right);<br>    dfs(left.right, right.left);<br>    dfs(right.left, right.right);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>637. 二叉树的层平均值</title>
    <link href="/2021/07/10/637-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC/"/>
    <url>/2021/07/10/637-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值 - 力扣（LeetCode）</a></p><p><img src="/2021/07/10/637-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC/image-20210710162805437.png" alt="image-20210710162805437"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1、直观思路：bfs 层次遍历，计算每一层的平均值 即可。</p><p>2、dfs 深度遍历，递归的时候维护每一个level的数量和总和</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 套用层次遍历的bfs</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Double&gt; <span class="hljs-title">averageOfLevels</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    ArrayList&lt;Double&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    LinkedList&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    q.offer(root);<br>    <span class="hljs-keyword">while</span> (!q.isEmpty()) &#123;<br>        <span class="hljs-keyword">int</span> size = q.size();<br>        ArrayList&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">double</span> sum = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            TreeNode cur = q.poll();<br>            tmp.add(cur.val);<br>            sum += cur.val;<br>            <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-keyword">null</span>)<br>                q.offer(cur.left);<br>            <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-keyword">null</span>)<br>                q.offer(cur.right);<br>        &#125;<br>        res.add(sum / size);<br>        <span class="hljs-comment">// 流处理  比较慢</span><br>        <span class="hljs-comment">//            double asDouble = tmp.stream().mapToDouble(Number::doubleValue).average().getAsDouble();</span><br>        <span class="hljs-comment">//            res.add(asDouble);</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 2.DFS 深度遍历，记录每一个level的总和、数量</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Double&gt; <span class="hljs-title">averageOfLevels</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    List&lt;Integer&gt; counts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(); <span class="hljs-comment">// 一层的数量</span><br>    List&lt;Double&gt; sums = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(); <span class="hljs-comment">// 一层的总和</span><br>    dfs(root, <span class="hljs-number">0</span>, counts, sums); <span class="hljs-comment">//从第0层开始构造 counts、nums</span><br>    List&lt;Double&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;Double&gt;();<br>    <span class="hljs-keyword">int</span> size = sums.size();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        res.add(sums.get(i) / counts.get(i));<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> level 第几层</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> counts</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> sums</span><br><span class="hljs-comment">     */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> level, List&lt;Integer&gt; counts, List&lt;Double&gt; sums)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (level &lt; sums.size())&#123;<br>        counts.set(level, counts.get(level) + <span class="hljs-number">1</span>);<br>        sums.set(level, sums.get(level) + root.val);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 没有该层，就默认为1</span><br>        counts.add(<span class="hljs-number">1</span>);<br>        sums.add((<span class="hljs-keyword">double</span>) root.val);<br>    &#125;<br>    dfs(root.left, level+<span class="hljs-number">1</span>, counts, sums);<br>    dfs(root.right, level+<span class="hljs-number">1</span>, counts, sums);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
      <tag>bfs</tag>
      
      <tag>dfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【合集】二叉树的遍历</title>
    <link href="/2021/07/07/%E3%80%90%E5%90%88%E9%9B%86%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <url>/2021/07/07/%E3%80%90%E5%90%88%E9%9B%86%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>参考：</p><p><a href="https://juejin.cn/post/6844904047107899400#heading-16">[leetcode]一套拳法👊刷掉n个遍历树的问题</a></p><p>labuladong的关于二叉树的网址</p><p>代码随想录 <a href="https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&amp;mid=2247485225&amp;idx=1&amp;sn=c6c97ea1234aa671287c6a4fe8392dba&amp;scene=21#wechat_redirect">二叉树：总结篇！（需要掌握的二叉树技能都在这里了）</a></p><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>⼆叉树主要有两种遍历⽅式：</p><ol><li><strong>深度优先遍历</strong>：先往深⾛，遇到叶⼦节点再往回⾛。（前序、中序、后序 都有递归法、迭代法）</li><li><strong>⼴度优先遍历</strong>：⼀层⼀层的去遍历。（层次遍历）</li></ol><p><img src="/2021/07/07/%E3%80%90%E5%90%88%E9%9B%86%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/image-20210710115310265.png" alt="image-20210710115310265"></p><p><img src="/2021/07/07/%E3%80%90%E5%90%88%E9%9B%86%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/image-20210710120625961.png" alt="image-20210710120625961"></p><h4 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h4><p>递归写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    dfs(root);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span>;<br>    dfs(root.left);<br>    res.add(root.val);<br>    dfs(root.right);<br>&#125;<br></code></pre></td></tr></table></figure><p>迭代写法：通过栈，压入各个节点；</p><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/bang-ni-dui-er-cha-shu-bu-zai-mi-mang-che-di-chi-t/">「代码随想录」帮你对二叉树不再迷茫，彻底吃透前中后序递归法（递归三部曲）和迭代法（不统一写法与统一写法） - 二叉树的后序遍历 - 力扣（LeetCode）</a></p><h4 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h4><h4 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h4><h4 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h4><p>​    BFS，广度优先搜索</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    Queue&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;(); <span class="hljs-comment">//队列</span><br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    q.offer(root); <span class="hljs-comment">//添加起点</span><br>    <span class="hljs-keyword">while</span> (!q.isEmpty()) &#123;<br>        <span class="hljs-keyword">int</span> size = q.size();<br>        List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(); <span class="hljs-comment">//保存该层元素</span><br>        <span class="hljs-comment">// 遍历这一层的node</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            TreeNode cur = q.poll();<br>            tmp.add(cur.val);<br>            <span class="hljs-comment">// 添加下一层可能的</span><br>            <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-keyword">null</span>)<br>                q.offer(cur.left);<br>            <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-keyword">null</span>)<br>                q.offer(cur.right);<br>        &#125;<br>        res.add(tmp);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h2><p>模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 广度优先，层次遍历</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">invertTree2</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    LinkedList&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>)<br>        q.offer(root);<br>    <span class="hljs-keyword">while</span> (!q.isEmpty()) &#123;<br>        <span class="hljs-comment">// 遍历这一层的</span><br>        <span class="hljs-keyword">int</span> size = q.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            TreeNode cur = q.poll();<br>            <span class="hljs-comment">// 做自己的处理逻辑</span><br>            <span class="hljs-comment">// ********************</span><br>            <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-keyword">null</span>)<br>                q.offer(cur.left);<br>            <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-keyword">null</span>)<br>                q.offer(cur.right);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="429-N-叉树的层序遍历"><a href="#429-N-叉树的层序遍历" class="headerlink" title="429. N 叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/">429. N 叉树的层序遍历</a></h4><p><img src="/2021/07/07/%E3%80%90%E5%90%88%E9%9B%86%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/image-20210710165445663.png" alt="image-20210710165445663"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    Queue&lt;List&lt;Node&gt;&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;(); <span class="hljs-comment">//队列</span><br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    q.offer(Arrays.asList(<span class="hljs-keyword">new</span> Node[]&#123;root&#125;)); <span class="hljs-comment">//添加起点</span><br>    <span class="hljs-keyword">while</span> (!q.isEmpty()) &#123;<br>        <span class="hljs-keyword">int</span> size = q.size();<br>        List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(); <span class="hljs-comment">//保存该层元素</span><br>        <span class="hljs-comment">// 遍历这一层的node</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            List&lt;Node&gt; cur = q.poll();<br>            <span class="hljs-keyword">for</span> (Node node : cur) &#123;<br>                tmp.add(node.val);<br>                <span class="hljs-comment">// 添加下一层可能的</span><br>                <span class="hljs-keyword">if</span> (node.children != <span class="hljs-keyword">null</span>)<br>                    q.offer(node.children);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (tmp.size() != <span class="hljs-number">0</span>)<br>            res.add(tmp);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="515-在每个树行中找最大值"><a href="#515-在每个树行中找最大值" class="headerlink" title="515. 在每个树行中找最大值"></a><a href="https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/">515. 在每个树行中找最大值</a></h4><p>​    您需要在二叉树的每一行中找到最大的值。</p><p>​    思路：每层求最大即可。</p><h4 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></h4><p>​    单独有博客</p><h4 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a></h4><p>两种方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 深度优先 -  递归</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// 对于root节点，要交换左右</span><br>    TreeNode tmp = root.left;<br>    root.left = root.right;<br>    root.right = tmp;<br><br>    <span class="hljs-comment">// dfs，递归调用左子树、右子树</span><br>    invertTree(root.left);<br>    invertTree(root.right);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-comment">// 广度优先，层次遍历</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">invertTree2</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    LinkedList&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>)<br>        q.offer(root);<br>    <span class="hljs-keyword">while</span> (!q.isEmpty()) &#123;<br>        <span class="hljs-comment">// 遍历这一层的</span><br>        <span class="hljs-keyword">int</span> size = q.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            TreeNode cur = q.poll();<br>            <span class="hljs-comment">// 交换左右节点</span><br>            TreeNode tmp = cur.left;<br>            cur.left = cur.right;<br>            cur.right = tmp;<br>            <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-keyword">null</span>)<br>                q.offer(cur.left);<br>            <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-keyword">null</span>)<br>                q.offer(cur.right);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h2><h4 id="递归注意"><a href="#递归注意" class="headerlink" title="递归注意"></a>递归注意</h4><p><img src="/2021/07/07/%E3%80%90%E5%90%88%E9%9B%86%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/image-20210712201019581.png" alt="image-20210712201019581"></p><p>比如反转二叉树：</p><p>​    1.TreeNode<em> invertTree(TreeNode</em> root)  </p><p>​    2.节点为空 返回  if (root == NULL) return root;  </p><p>​    3.每一层交换左右节点即可；然后反转左⼦树，反转右⼦树  </p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-built_in">swap</span>(root-&gt;<span class="hljs-built_in">left</span>, root-&gt;<span class="hljs-built_in">right</span>);<br>invertTree(root-&gt;<span class="hljs-built_in">left</span>);<br>invertTree(root-&gt;<span class="hljs-built_in">right</span>);  <br></code></pre></td></tr></table></figure><h4 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a><a href="https://leetcode-cn.com/problems/same-tree/">100. 相同的树</a></h4><p><img src="/2021/07/07/%E3%80%90%E5%90%88%E9%9B%86%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/image-20210711104756433.png" alt="image-20210711104756433"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(TreeNode p, TreeNode q)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span> &amp;&amp; q == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span> &amp;&amp; q != <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">if</span> (q == <span class="hljs-keyword">null</span> &amp;&amp; p != <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">if</span> (p.val == q.val)&#123;<br>        <span class="hljs-comment">//当前节点相同，比较左右子节点</span><br>        <span class="hljs-keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="⭐101-对称二叉树"><a href="#⭐101-对称二叉树" class="headerlink" title="⭐101. 对称二叉树"></a>⭐<a href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a></h4><ol><li><p>确定递归函数的参数和返回值  </p><p>比较两个子树是否翻转，参数两个子树</p></li><li><p>确定终⽌条件  </p><p>两个节点的情况，为null情况，都不为null情况</p><p>左节点为空，右节点不为空，不对称， return false<br>左不为空，右为空，不对称 return false<br>左右都为空，对称，返回true<br>左右都不为空，⽐较节点数值，不相同就return false  </p></li><li><p>确定单层递归的逻辑  </p><p>比较左左-右右，左右-右左，外侧和内侧。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">return</span> dfs(root.left, root.right);<br>&#125;<br><span class="hljs-comment">// 递归</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode left, TreeNode right)</span></span>&#123;<br>    <span class="hljs-comment">// 2.确定终止条件</span><br>    <span class="hljs-keyword">if</span> (left == <span class="hljs-keyword">null</span> &amp;&amp; right == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">if</span> (left == <span class="hljs-keyword">null</span> || right == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">//这里left、right有一个为null，另一个不为null</span><br>    <span class="hljs-keyword">if</span> (left.val != right.val)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-comment">// 当前相等比较下面，左左 和 右右</span><br>    <span class="hljs-keyword">return</span> dfs(left.left, right.right) &amp;&amp; dfs(left.right, right.left);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="226-翻转二叉树-1"><a href="#226-翻转二叉树-1" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a></h4><p><img src="/2021/07/07/%E3%80%90%E5%90%88%E9%9B%86%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/image-20210711105454468.png" alt="image-20210711105454468"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// 对于root节点，要交换左右</span><br>    TreeNode tmp = root.left;<br>    root.left = root.right;<br>    root.right = tmp;<br><br>    <span class="hljs-comment">// dfs，递归调用左子树、右子树</span><br>    invertTree(root.left);<br>    invertTree(root.right);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h4><p><img src="/2021/07/07/%E3%80%90%E5%90%88%E9%9B%86%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/image-20210711110441326.png" alt="image-20210711110441326"></p><p>一种理解：maxDepth()能返回最大深度，对于root节点来说，左子树/右子树最大值 + 1，就是最大深度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">int</span> leftHeight = maxDepth(root.left);<br>        <span class="hljs-keyword">int</span> rightHeight = maxDepth(root.right);<br>        <span class="hljs-keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>另一种，dfs常见的，递归的时候加入参数depth 表明当前节点的深度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>; <span class="hljs-comment">//最大深度</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    dfs(root, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br><span class="hljs-comment">// depth记录 当前节点 所在深度</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> depth)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (depth &gt; max)<br>        max = depth;<br>    dfs(root.left, depth+<span class="hljs-number">1</span>);<br>    dfs(root.right, depth+<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="559-N-叉树的最大深度"><a href="#559-N-叉树的最大深度" class="headerlink" title="559. N 叉树的最大深度"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/">559. N 叉树的最大深度</a></h4><p><img src="/2021/07/07/%E3%80%90%E5%90%88%E9%9B%86%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/image-20210711111246194.png" alt="image-20210711111246194"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(Node root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; root.children.size(); i++) &#123;<br>        <span class="hljs-comment">// 递归测量所有子树的深度</span><br>        <span class="hljs-keyword">int</span> tmp = maxDepth(root.children.get(i));<br>        <span class="hljs-keyword">if</span> (max &lt; tmp)<br>            max = tmp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> max + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="⭐110-平衡二叉树"><a href="#⭐110-平衡二叉树" class="headerlink" title="⭐110. 平衡二叉树"></a>⭐<a href="https://leetcode-cn.com/problems/balanced-binary- tree/">110. 平衡二叉树</a></h4><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-comment">// 不为-1，说明平衡</span><br>    <span class="hljs-keyword">return</span> getDepth(root) != -<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 获取树的深度，如果不是平衡二叉树，返回-1</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDepth</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>    <span class="hljs-comment">// 2.终止条件，为null，深度0</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* 3.单层逻辑</span><br><span class="hljs-comment">        左子树/右子树不平衡 直接-1，整棵树不平衡</span><br><span class="hljs-comment">        左右子树深度大于1，不平衡</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">int</span> left = getDepth(root.left);<br>    <span class="hljs-keyword">if</span> (left == -<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> right = getDepth(root.right);<br>    <span class="hljs-keyword">if</span> (right == -<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (Math.abs(left - right) &gt; <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + Math.max(left, right); <span class="hljs-comment">// 以当前节点为根节点的最⼤⾼度</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="⭐剑指-Offer-68-II-二叉树的最近公共祖先"><a href="#⭐剑指-Offer-68-II-二叉树的最近公共祖先" class="headerlink" title="⭐剑指 Offer 68 - II. 二叉树的最近公共祖先"></a>⭐<a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - II. 二叉树的最近公共祖先</a></h4><p>​    见单独的博客</p><p>​    <a href="https://yooyep.github.io/2021/07/13/[剑指]68-II-二叉树的最近公共祖先/">【剑指】68 - II. 二叉树的最近公共祖先 - yooyep’s space</a></p><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><h4 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></h4><p><img src="/2021/07/07/%E3%80%90%E5%90%88%E9%9B%86%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/image-20210707212650219.png" alt="image-20210707212650219"></p><p>一开始递归的时候，忘记写上return了。。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (root.val == val)<br>        <span class="hljs-keyword">return</span> root;<br>    <span class="hljs-keyword">if</span> (root.val &lt; val)<br>        <span class="hljs-keyword">return</span> searchBST(root.right, val); <span class="hljs-comment">//比当前大，递归右子树</span><br>    <span class="hljs-keyword">if</span> (root.val &gt; val)<br>        <span class="hljs-keyword">return</span> searchBST(root.left, val);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>98. 验证二叉搜索树</title>
    <link href="/2021/07/07/98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2021/07/07/98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树 - 力扣（LeetCode）</a></p><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1、中序遍历，看是否严格升序</p><p>2、递归，不满足的条件直接false，递归左右子树（有坑）</p><p>​    一开始这样写，但是这是从小的子树判断是否符合二叉搜索树，再看大的树。但解决不了下图的情况。<br>​    因此只好传入限制的边界min、max</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">if</span> (root.left != <span class="hljs-keyword">null</span> &amp;&amp; root.val &lt;= root.left.val)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">if</span> (root.right != <span class="hljs-keyword">null</span> &amp;&amp; root.val &gt;= root.right.val)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-keyword">return</span> isValidBST(root.left)<br>        &amp;&amp; isValidBST(root.right);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2021/07/07/98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/image-20210707210232393.png" alt="image-20210707210232393"></p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><h3 id="第一种思路"><a href="#第一种思路" class="headerlink" title="第一种思路"></a>第一种思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-comment">// 第一种，查看是否严格递增</span><br>    inorder(root);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; res.size(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (res.get(i) &lt;= res.get(i-<span class="hljs-number">1</span>))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span>;<br>    inorder(root.left);<br>    res.add(root.val);<br>    inorder(root.right);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第二种思路"><a href="#第二种思路" class="headerlink" title="第二种思路"></a>第二种思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> dfs(root, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>&#125;<br><span class="hljs-comment">// min、max为当前节点最大最小值，且不能取到 max.val &gt; root.val &gt; min.val</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root, TreeNode min, TreeNode max)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-comment">// 不符合 max 和 min 的限制，说明不是合法 BST</span><br>    <span class="hljs-keyword">if</span> (min != <span class="hljs-keyword">null</span> &amp;&amp; root.val &lt;= min.val)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">if</span> (max != <span class="hljs-keyword">null</span> &amp;&amp; root.val &gt;= max.val)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">// 如果当前满足，递归左右子树</span><br>    <span class="hljs-comment">// 左子树，最大值就是当前节点；右子树最小值就是当前节点</span><br>    <span class="hljs-keyword">return</span> dfs(root.left, min, root)<br>            &amp;&amp; dfs(root.right, root, max);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="更妙思路"><a href="#更妙思路" class="headerlink" title="更妙思路"></a>更妙思路</h3><p>仍然是中序遍历，判断当前节点是否大于中序遍历的前一个节点（pre），如果大于，说明满足 BST，继续遍历；否则直接返回 false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">long</span> pre = Long.MIN_VALUE;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 访问左子树</span><br>        <span class="hljs-keyword">if</span> (!isValidBST(root.left)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 访问当前节点：如果当前节点小于等于中序遍历的前一个节点，说明不满足BST，返回 false；否则继续遍历。</span><br>        <span class="hljs-keyword">if</span> (root.val &lt;= pre) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        pre = root.val;<br>        <span class="hljs-comment">// 访问右子树</span><br>        <span class="hljs-keyword">return</span> isValidBST(root.right);<br>    &#125;<br>&#125;<br><br>作者：sweetiee<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/validate-binary-search-tree/solution/zhong-xu-bian-li-qing-song-na-xia-bi-xu-miao-dong-/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>538. 把二叉搜索树转换为累加树</title>
    <link href="/2021/07/07/538-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/"/>
    <url>/2021/07/07/538-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树 - 力扣（LeetCode）</a></p><p><img src="/2021/07/07/538-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/image-20210707204030125.png" alt="image-20210707204030125"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>中序的反序遍历就是 从大到小的顺序，依次把其相加即可。</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">convertBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">//记录从大到小的总和 （中序倒着过来就是从大到小）</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        dfs(root.right);<br>        sum += root.val;<br>        root.val = sum; <span class="hljs-comment">//重新赋值</span><br>        dfs(root.left);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>230. 二叉搜索树中第K小的元素</title>
    <link href="/2021/07/07/230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/"/>
    <url>/2021/07/07/230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素 - 力扣（LeetCode）</a></p><p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 个最小元素（从 1 开始计数）。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二叉搜索树</p><p>​    对于每个node来说，左子树的节点值都比node值要小，右子树的节点值都比node值要大。</p><p>因此，BST 的中序遍历结果是升序的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;<br>    traverse(root.left);<br>    <span class="hljs-comment">// 中序遍历代码位置</span><br>    print(root.val);<br>    traverse(root.right);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">c230_BST_kth</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> val;<br>        TreeNode left;<br>        TreeNode right;<br>        TreeNode() &#123;&#125;<br>        TreeNode(<span class="hljs-keyword">int</span> val) &#123; <span class="hljs-keyword">this</span>.val = val; &#125;<br>        TreeNode(<span class="hljs-keyword">int</span> val, TreeNode left, TreeNode right) &#123;<br>            <span class="hljs-keyword">this</span>.val = val;<br>            <span class="hljs-keyword">this</span>.left = left;<br>            <span class="hljs-keyword">this</span>.right = right;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>; <span class="hljs-comment">//记录结果</span><br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">//记录第k个</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.count = k;<br>        traverse(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        traverse(root.left);<br>        <span class="hljs-keyword">if</span> (--count == <span class="hljs-number">0</span>)&#123;<br>            res = root.val;<br>            <span class="hljs-keyword">return</span>; <span class="hljs-comment">//找到第k个小的</span><br>        &#125;<br>        traverse(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相似题目"><a href="#相似题目" class="headerlink" title="相似题目"></a>相似题目</h2><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指 Offer 54. 二叉搜索树的第k大节点 - 力扣（LeetCode）</a></p><p>第k大节点，中序的翻版即可（先遍历right、再遍历left）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res, k;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kthLargest</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.k = k;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;<br>        dfs(root.right);<br>        <span class="hljs-keyword">if</span> (--k == <span class="hljs-number">0</span>)&#123;<br>            res = root.val; <span class="hljs-comment">//找到第k个大的</span><br>        &#125;<br>        dfs(root.left);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 代理模式</title>
    <link href="/2021/07/07/Java-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/07/07/Java-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>参考：</p><p><a href="https://segmentfault.com/a/1190000011291179">Java三种代理模式：静态代理、动态代理和cglib代理 - SegmentFault 思否</a></p><p><a href="https://mp.weixin.qq.com/s/HFMlfC-ocGBXXgxYWKND9g">Java进阶 | Proxy动态代理机制详解</a></p><p><a href="https://blog.51cto.com/u_15127599/2751783">JDK动态代理-超详细源码分析_mob604756f61e6c的技术博客_51CTO博客</a></p><h2 id="一、代理模式"><a href="#一、代理模式" class="headerlink" title="一、代理模式"></a>一、代理模式</h2><p>代理模式给一个目标对象提供一个代理对象，并由代理对象持有目标对象的引用。可以通过代理对象访问目标对象，可以在不改变目标对象的基础上，提供额外的功能。</p><p>起到中介的作用（中介、律师、代购），比如我想结婚（目标对象），可以找婚介公司（代理对象）完成帮我租场地、节目安排等操作，我在其中只需要结婚即可。AOP编程就是基于这个思想。</p><p><img src="/2021/07/07/Java-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/image-20210707162820927.png" alt="image-20210707162820927"></p><h2 id="二、静态代理"><a href="#二、静态代理" class="headerlink" title="二、静态代理"></a>二、静态代理</h2><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：可以在不修改目标对象的前提下扩展目标对象的功能。</p><p>缺点：</p><ul><li><p>冗余。由于代理对象要实现与目标对象一致的接口，会产生过多的代理类。</p></li><li><p>不易维护。一旦接口增加方法，目标对象与代理对象都要进行修改。</p></li></ul><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>接口类：IUserDao</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IUserDao</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现类：UserDaoImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IUserDao</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;保存数据&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代理类：UserDaoProxy，其中有一个引用target访问实体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IUserDao</span></span>&#123;<br>    <span class="hljs-keyword">private</span> IUserDao target; <span class="hljs-comment">//目标对象</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserDaoProxy</span><span class="hljs-params">(IUserDao target)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.target = target; <span class="hljs-comment">//构造函数，传入目标对象</span><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;开启事务&quot;</span>);<span class="hljs-comment">//扩展了额外功能</span><br>        target.save();<br>        System.out.println(<span class="hljs-string">&quot;提交事务&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestStaticUserProxy</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//目标对象</span><br>        UserDaoImpl target = <span class="hljs-keyword">new</span> UserDaoImpl();<br>        <span class="hljs-comment">//代理对象</span><br>        UserDaoProxy proxy = <span class="hljs-keyword">new</span> UserDaoProxy(target);<br>        proxy.save();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、JDK的动态代理"><a href="#三、JDK的动态代理" class="headerlink" title="三、JDK的动态代理"></a>三、JDK的动态代理</h2><p>JDK动态代理的步骤：</p><p>（1）创建被代理对象的接口类。</p><p>（2）创建具体被代理对象接口的实现类。</p><p>（3）创建一个InvocationHandler的实现类，并持有被代理对象的引用。然后在invoke方法中利用反射调用被代理对象的方法。</p><p>（4）利用Proxy.newProxyInstance方法创建代理对象，利用代理对象实现真实对象方法的调用。</p><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><p>UserInvocationHandler类，对应第三步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Object target; <span class="hljs-comment">//代理对象</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserInvocationHandler</span><span class="hljs-params">(Object target)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.target = target;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;开启事务 dynamic&quot;</span>);<br><br>        <span class="hljs-comment">// 执行目标对象方法</span><br>        Object returnValue = method.invoke(target, args);<br><br>        System.out.println(<span class="hljs-string">&quot;提交事务 dynamic&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试，对应第（4）步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestDynamicProxy</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        IUserDao target = <span class="hljs-keyword">new</span> UserDaoImpl();<br>        System.out.println(target.getClass()); <span class="hljs-comment">//输出目标对象信息</span><br><br>        UserInvocationHandler handler = <span class="hljs-keyword">new</span> UserInvocationHandler(target);<br>        <span class="hljs-comment">//第一个参数是指定代理类的类加载器（我们传入当前测试类的类加载器）</span><br>        <span class="hljs-comment">//第二个参数是代理类需要实现的接口（我们传入被代理类实现的接口，这样生成的代理类和被代理类就实现了相同的接口）</span><br>        <span class="hljs-comment">//第三个参数是invocation handler，用来处理方法的调用。这里传入我们自己实现的handler</span><br>        IUserDao proxyInstance = (IUserDao) Proxy.newProxyInstance(target.getClass().getClassLoader(),<br>                               target.getClass().getInterfaces(), handler);<br>        System.out.println(proxyInstance.getClass());  <span class="hljs-comment">//输出代理对象信息</span><br>        proxyInstance.save();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>静态代理与动态代理的区别主要在：</p><ul><li><p>静态代理的目标对象和代理对象，在代理前就确定下了，实现同一个接口。编译完成后代理类是一个实际的class文件</p></li><li><p>动态代理是利用反射机制动态生成一个实现代理接口的匿名类$Proxy.class，业务处理之外的代码在InvocationHandler 处理。匿名类实现InvocationHandler 接口，继承Proxy类。没有实际的class文件，动态生成加载到JVM中</p></li></ul><p>动态代理对象不需要实现接口，但是<strong>要求目标对象必须实现接口</strong>，否则不能使用动态代理。</p><p>原因：生成的代理类会继承Proxy类，但 Java 是不支持多重继承的。</p><p>（cglib解决，通过在运行时在内存中动态生成一个子类对象，完成功能扩展）</p><h3 id="生成的-Proxy0-class"><a href="#生成的-Proxy0-class" class="headerlink" title="生成的$Proxy0.class"></a>生成的$Proxy0.class</h3><p>其中省略了equals、hashcode、toString方法，可以继承了Proxy类，实现了IUserDao接口。</p><p>构造方法传入InvocationHandler，当调用的时候，super.h.invoke()，其中super.h就是我们传入的UserInvocationHandler，调用其中的invoke方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> $<span class="hljs-title">Proxy0</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IUserDao</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m1;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m2;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m3;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m0;<br><br>    <span class="hljs-keyword">public</span> $Proxy0(InvocationHandler var1) <span class="hljs-keyword">throws</span>  &#123;<br>        <span class="hljs-keyword">super</span>(var1);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">save</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (String)<span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m3, (Object[])<span class="hljs-keyword">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var2) &#123;<br>            <span class="hljs-keyword">throw</span> var2;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var3) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var3);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            m1 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;equals&quot;</span>, Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>));<br>            m2 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;toString&quot;</span>);<br>            m3 = Class.forName(<span class="hljs-string">&quot;zlearn.proxy.IUserDao&quot;</span>).getMethod(<span class="hljs-string">&quot;save&quot;</span>);<br>            m0 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;hashCode&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException var2) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchMethodError(var2.getMessage());<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException var3) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoClassDefFoundError(var3.getMessage());<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>143. 重排链表</title>
    <link href="/2021/07/02/143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/07/02/143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode-cn.com/problems/reorder-list/">143. 重排链表 - 力扣（LeetCode）</a></p><p>给定一个单链表 <em>L</em>：<em>L</em>0→<em>L</em>1→…→<em>L**n</em>-1→<em>L</em>n ，<br>将其重新排列后变为： <em>L</em>0→<em>L**n</em>→<em>L</em>1→<em>L**n</em>-1→<em>L</em>2→<em>L**n</em>-2→…</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean">示例 <span class="hljs-number">1</span>:<br>给定链表 <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>, 重新排列为 <span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3.</span><br>示例 <span class="hljs-number">2</span>:<br>给定链表 <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>, 重新排列为 <span class="hljs-number">1</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">3.</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>1、重排链表，新建另一个链表，再拷贝回值（不符合题意，一开始感觉的办法）</p><p>2、node存放在链表中，调整位置（推荐）</p><p>3、先找到链表中点， 链表逆序，链表合并（融合了力扣876、206、21）</p><ul><li><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">876. 链表的中间结点 - 力扣（LeetCode）</a></li><li><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表 - 力扣（LeetCode）</a></li><li><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表 - 力扣（LeetCode）</a></li></ul><p><strong>注意：</strong><br>方法中传入参数为head（java是值传递，传入基本数据类型int、引用类型，都不会改变值/引用地址）</p><p><a href="https://blog.csdn.net/ZZY_Yang/article/details/79537869">Java参数在方法中传递发生的值改变_ZZY的博客-CSDN博客</a></p><ul><li>head.next修改，能改变原有变量。</li><li>head = newHead修改，不能改变原有变量。</li></ul><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">c143_reorderList</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1、重排链表，新建另一个链表，再拷贝回值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> head</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        ListNode head1 = head;<br>        <span class="hljs-comment">// 1.存储原来的元素</span><br>        ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) &#123;<br>            list.add(head.val);<br>            head = head.next;<br>        &#125;<br>        ListNode newHead = <span class="hljs-keyword">new</span> ListNode();<br>        ListNode tail = newHead;<br>        <span class="hljs-keyword">int</span> sz = list.size() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= list.size() / <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i != (sz - i))&#123;<br>                ListNode node = <span class="hljs-keyword">new</span> ListNode(list.get(i));<br>                ListNode node1 = <span class="hljs-keyword">new</span> ListNode(list.get(sz - i));<br>                node.next = node1; <span class="hljs-comment">//连接这两个</span><br>                tail.next = node;<br>                tail = node1; <span class="hljs-comment">//重新移到尾部</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 相等，中间一项</span><br>                ListNode node = <span class="hljs-keyword">new</span> ListNode(list.get(i));<br>                tail.next = node;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 2.修改原链表中的值</span><br>        newHead = newHead.next; <span class="hljs-comment">//跳过0这项</span><br>        <span class="hljs-keyword">while</span> (head1 != <span class="hljs-keyword">null</span>) &#123;<br>            head1.val = newHead.val;<br>            head1 = head1.next;<br>            newHead = newHead.next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 2、node存放在链表中，调整位置</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> head</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reorderList2</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        ListNode node = head;<br>        ArrayList&lt;ListNode&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-keyword">null</span>)&#123;<br>            list.add(node);<br>            node = node.next;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = list.size() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right)&#123;<br>            list.get(left).next = list.get(right); <span class="hljs-comment">// LO -&gt; Ln</span><br>            left++;<br>            <span class="hljs-keyword">if</span> (left == right) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            list.get(right).next = list.get(left); <span class="hljs-comment">// Ln -&gt; L1</span><br>            right--;<br>        &#125;<br>        list.get(left).next = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 3、先找到链表中点， 链表逆序，链表合并</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> head</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reorderList3</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span> || head.next.next == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 1. 获取链表中点</span><br>        ListNode middleNode = middleNode(head);<br>        <span class="hljs-comment">// 2.将中间一切为二</span><br>        <span class="hljs-comment">// 这里故意保证前半段l1较长，在后面合并的时候，默认以l1为主，l2为null，l1自动在后面；</span><br>        <span class="hljs-comment">// 如果l2长，l1就少了一段；</span><br>        ListNode l1 = head;<br>        ListNode l2 = middleNode.next; <span class="hljs-comment">//如果是12345，l2就是45</span><br>        <span class="hljs-keyword">while</span> (head != middleNode)&#123;<br>            head = head.next;<br>        &#125;<br>        head.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">//在3后面 切断</span><br><br>        <span class="hljs-comment">// 3.链表逆序</span><br>        l2 = reverseList(l2);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            3.将l1、l2两个链表变为一个，且不能新建，只是更改顺序；</span><br><span class="hljs-comment">                l1 1-&gt;3-&gt;5</span><br><span class="hljs-comment">                l2 4-&gt;2</span><br><span class="hljs-comment">                先取出3-5，1-4-2相连，再1-4-3-5相连；</span><br><span class="hljs-comment">                更新l1、l2为 3-5、2</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-keyword">null</span> &amp;&amp; l2 != <span class="hljs-keyword">null</span>)&#123;<br>            ListNode next = l1.next;<br>            l1.next = l2; <span class="hljs-comment">// 1链接到2</span><br>            l2 = l2.next; <span class="hljs-comment">// 链表向后移动</span><br>            l1.next.next = next; <span class="hljs-comment">// 1原本的 重新链接到1</span><br>            l1 = next; <span class="hljs-comment">// 更新1</span><br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">// 寻找链表中点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title">middleNode</span><span class="hljs-params">(ListNode head)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        ListNode slow = head, fast = head;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>)&#123;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br><br>    <span class="hljs-comment">// 逆序链表</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 头插法，默认就是逆序</span><br>        ListNode node = <span class="hljs-keyword">null</span>; <span class="hljs-comment">//虚的头节点</span><br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>)&#123;<br>            ListNode tmp = <span class="hljs-keyword">new</span> ListNode(head.val);<br>            tmp.next = node;<br>            node = tmp;<br>            head = head.next; <span class="hljs-comment">//向后移动</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ListNode node = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;);<br>        System.out.println(node.toString());<br>        reorderList3(node);<br>        System.out.println(node.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指】56 - I. 数组中数字出现的次数</title>
    <link href="/2021/07/01/%E3%80%90%E5%89%91%E6%8C%87%E3%80%9156-I-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
    <url>/2021/07/01/%E3%80%90%E5%89%91%E6%8C%87%E3%80%9156-I-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">剑指 Offer 56 - I. 数组中数字出现的次数 - 力扣（LeetCode）</a></p><p>一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">示例 1：<br>输入：nums = <span class="hljs-comment">[4,1,4,6]</span><br>输出：<span class="hljs-comment">[1,6]</span> 或 <span class="hljs-comment">[6,1]</span><br><br>示例 2：<br>输入：nums = <span class="hljs-comment">[1,2,10,4,1,4,3,3]</span><br>输出：<span class="hljs-comment">[2,10]</span> 或 <span class="hljs-comment">[10,2]</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>补充异或的性质</p><p><img src="/2021/07/01/%E3%80%90%E5%89%91%E6%8C%87%E3%80%9156-I-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/image-20210701102733431.png" alt="image-20210701102733431"></p><p>如果只有一个出现一次的数字，可以直接异或得到 1 ^ 4 ^ 4 = 1；</p><p>1、如果是题目中有两个出现一次的数字，只能得到这两个数字的异或 4 ^ 1 ^ 4 ^ 6 =&gt; 1 ^ 6 </p><p>2、找到x^y的一位为1，将x、y分开到两组中（相同的数，肯定在一组）</p><p>   1^6 = (001) ^ (110) = 111，我们可以按最低位的1（该位，两个数相异），将所有数分为两组，这样1、6就分开了。</p><p>3、分别将两组进行异或，就可以得到x、y了。</p><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] singleNumbers(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>, mask = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 1.</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>        res ^= num;<br>    &#125;<br>    <span class="hljs-comment">// 2.</span><br>    <span class="hljs-keyword">while</span> ((res &amp; mask) == <span class="hljs-number">0</span>)&#123;<br>        mask &lt;&lt;= <span class="hljs-number">1</span>; <span class="hljs-comment">// mask只有一位为1，找出x^y中 二进制位为1的位；</span><br>    &#125;<br>    <span class="hljs-comment">// 3.</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>        <span class="hljs-keyword">if</span> ((num &amp; mask) == <span class="hljs-number">0</span>)<br>            x ^= num;<br>        <span class="hljs-keyword">else</span><br>            y ^= num;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;x,y&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写一个简单的RPC项目</title>
    <link href="/2021/06/22/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84RPC%E9%A1%B9%E7%9B%AE/"/>
    <url>/2021/06/22/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84RPC%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h3 id><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>记录rpc项目中的bug</title>
    <link href="/2021/06/19/%E8%AE%B0%E5%BD%95rpc%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84bug/"/>
    <url>/2021/06/19/%E8%AE%B0%E5%BD%95rpc%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84bug/</url>
    
    <content type="html"><![CDATA[<h3 id="序列化与空参构造器"><a href="#序列化与空参构造器" class="headerlink" title="序列化与空参构造器"></a>序列化与空参构造器</h3><p>在序列化过程中，发现没有空参构造器，报错了。但是记得之前有次也是没写空参构造器，序列化能行。于是看了下网上对其的解析。</p><blockquote><p><a href="https://www.jianshu.com/p/b6797afff7df">从源码解析JAVA序列化是否需要空参构造方法？ - 简书</a></p></blockquote><p>1、Person实现Serializable接口，没有空参构造器，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-comment">//@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>&#125;<br></code></pre></td></tr></table></figure><p>JDK原本的序列化，可以成功；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">//序列化</span><br>    ObjectOutputStream objectOutputStream = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;2.txt&quot;</span>));<br>    Person person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;111&quot;</span>);<br>    objectOutputStream.writeObject(person);<br>    <span class="hljs-comment">//反序列化</span><br>    ObjectInputStream objectInputStream = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;2.txt&quot;</span>));<br>    Person person1 = (Person) objectInputStream.readObject();<br>    System.out.println(person1.toString());<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>但是jackjson的序列化失败；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Person person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;cjc&quot;</span>);<br>ObjectMapper objectMapper = <span class="hljs-keyword">new</span> ObjectMapper();<br><span class="hljs-keyword">byte</span>[] bytes = objectMapper.writeValueAsBytes(person);<br>System.out.println(<span class="hljs-keyword">new</span> String(bytes));<br><br><span class="hljs-comment">// 读取 序列化的结果</span><br>Person person1 = objectMapper.readValue(bytes, Person.class);<br>System.out.println(person1);<br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&#123;&quot;name&quot;:&quot;cjc&quot;&#125;<br><br>com.fasterxml.jackson.databind.exc.MismatchedInputException: Cannot construct instance <span class="hljs-keyword">of</span> `Person` (although at least one Creator <span class="hljs-keyword">exists</span>): cannot deserialize <span class="hljs-keyword">from</span> <span class="hljs-keyword">Object</span> <span class="hljs-keyword">value</span> (<span class="hljs-keyword">no</span> delegate- <span class="hljs-keyword">or</span> property-based Creator)<br> at [Source: (byte[])&quot;&#123;&quot;<span class="hljs-type">name</span>&quot;:&quot;cjc&quot;&#125;&quot;; <span class="hljs-type">line</span>: <span class="hljs-number">1</span>, <span class="hljs-keyword">column</span>: <span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>2、子父类都没有空参构造器，父类实现Serializable接口，子类间接实现Serializable接口,序列化子类对象sub</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Data</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Data</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.n = n;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Data&#123;&quot;</span> +<br>            <span class="hljs-string">&quot;n=&#x27;&quot;</span> + n + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>            <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>        <span class="hljs-comment">//            return Integer.toString(n);</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">sub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Data</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> k;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(n);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;sub&#123;&quot;</span> +<br>            <span class="hljs-string">&quot;k=&quot;</span> + k +<br>            <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>序列化，可以正常运行，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ObjectOutputStream out = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;worm.out&quot;</span>));<br>sub d = <span class="hljs-keyword">new</span> sub(<span class="hljs-number">10</span>);<br>out.writeObject(d);<br><br>ObjectInputStream in = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;worm.out&quot;</span>));<br>sub f = (sub) in.readObject();<br>System.out.println(f);<br></code></pre></td></tr></table></figure><p>3、父类不实现Serializable接口，子类实现Serializable接口，序列化子类；（均无空参构造器）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Data</span> </span>&#123; <br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">sub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Data</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>&#123;<br></code></pre></td></tr></table></figure><p>序列化失败</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java.io.InvalidClassException: DataTest$sub; no valid constructor<br>at java.base/java.io.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ObjectStreamClass$ExceptionInfo</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">InvalidClassException(ObjectStreamClass.<span class="hljs-params">java</span>:168)</span><br>at java.base/java.io.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ObjectStreamClass</span>.</span></span>check<span class="hljs-constructor">Deserialize(ObjectStreamClass.<span class="hljs-params">java</span>:907)</span><br></code></pre></td></tr></table></figure><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p>在ObjectStreamClass中的getSerializableConstructor方法，是引发异常的原因，注释写道，返回第一个非可序列化超类的子类可访问的no-arg构造函数；找不到返回null，就失败了；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ObjectStreamClass.java</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns subclass-accessible no-arg constructor of first non-serializable</span><br><span class="hljs-comment">     * superclass, or null if none found.  Access checks are disabled on the</span><br><span class="hljs-comment">     * returned constructor (if any).</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Constructor&lt;?&gt; getSerializableConstructor(Class&lt;?&gt; cl) &#123;<br></code></pre></td></tr></table></figure><p>第一、第二个案例JDK序列化成功，是因为第一个非序列化子类为Object，Object有默认空参构造器，所以可以运行；</p><p>第三个案例，第一个非序列化子类为Data，没有空参构造器，所以失败；</p><p>在<a href="https://blog.csdn.net/zh15732621679/article/details/79803105">Java学习笔记(十三)—序列化、反序列化与无参构造函数_至尊宝-CSDN博客_java反序列化函数</a> 中的三个，也可以通过这个结论来解释。</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用hexo搭建博客</title>
    <link href="/2021/06/17/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2021/06/17/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="windows下使用hexo搭建博客"><a href="#windows下使用hexo搭建博客" class="headerlink" title="windows下使用hexo搭建博客"></a>windows下使用hexo搭建博客</h2><p>参考教程：<a href="https://zhuanlan.zhihu.com/p/24019875">【超简单】Windows下使用GitHub + Hexo搭建技术博客 - 知乎</a></p><h3 id="安装Node-js和git"><a href="#安装Node-js和git" class="headerlink" title="安装Node.js和git"></a>安装Node.js和git</h3><p>安装node.js的问题：出现Invalid drive F:错误</p><p>解决：subst F:%TEMP%，再安装x86；之前一直F:后多打了空格，导致不行。<br><a href="https://blog.csdn.net/chan70707/article/details/60337045">    删除了目录卸载或安装出现Invalid drive错误_chan70707的专栏-CSDN博客</a></p><p>node -v    #查看node版本<br>npm -v    #查看npm版本<br>git —version #查看版本<br>    git 需要配置ssh等</p><h3 id="本地配置hexo"><a href="#本地配置hexo" class="headerlink" title="本地配置hexo"></a>本地配置hexo</h3><p>npm install -g cnpm —registry=<a href="https://registry.npm.taobao.org">https://registry.npm.taobao.org</a> #安装cnpm<br>cnpm install -g hexo-cli    #安装hexo框架<br>hexo -v    #查看hexo版本</p><p>hexo init     #生成博客 初始化博客<br>hexo n 使用hexo搭建博客<br>hexo s  #启动本地博客服务 <a href="http://localhost:4000/">http://localhost:4000/</a><br>hexo clean  #清理<br>hexo g  #生成<br>hexo d  #部署到Github仓库里 <a href="https://yooyep.github.io/">https://yooyep.github.io/</a> </p><p>使用的主题：fluid<br>修改主题背景图片等：E:\blog\node_modules\hexo-theme-fluid\source</p><h3 id="图片的插入-配合typora设置"><a href="#图片的插入-配合typora设置" class="headerlink" title="图片的插入 配合typora设置"></a>图片的插入 配合typora设置</h3><p>参考设置：<a href="https://cloud.tencent.com/developer/article/1702112">hexo 图片显示问题及使用typora设置图片路径 - 云+社区 - 腾讯云</a></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog">设置post_asset_folder 为 true, 安装插件 asset-image<br>npm install https:<span class="hljs-comment">//github.com/CodeFalling/hexo-asset-image</span><br>设置图片为相对路径<br>hexo clean &amp;&amp; hexo <span class="hljs-keyword">generate</span> &amp;&amp; hexo s 运行查看<br></code></pre></td></tr></table></figure><p>typora设置</p><p><img src="/2021/06/17/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20210617192105639.png" alt="image-20210617192105639"></p><p>生成的本地文件夹</p><p><img src="/2021/06/17/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20210617192201773.png" alt="image-20210617192201773"></p><p>—ending</p><p><img src="/2021/06/17/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20210617171119218.png" alt="image-20210617171119218"></p><h2 id="fluid主题"><a href="#fluid主题" class="headerlink" title="fluid主题"></a>fluid主题</h2><h3 id="标题目录的问题"><a href="#标题目录的问题" class="headerlink" title="标题目录的问题"></a>标题目录的问题</h3><p>原本的md目录很多</p><p><img src="/2021/06/17/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20210713085829692.png" alt="image-20210713085829692"></p><p>但是默认主题的目录会自动收缩，没办法直接看到全部目录</p><p><img src="/2021/06/17/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20210713085929642.png" alt="image-20210713085929642"></p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>1.将css关于自动收缩的代码注释掉。</p><p>​    main.css中注释掉以下代码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*.tocbot-is-collapsed &#123;</span><br><span class="hljs-comment">  max-height: 0;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">.tocbot-is-collapsible &#123;</span><br><span class="hljs-comment">  overflow: hidden;</span><br><span class="hljs-comment">  transition: all 0.3s ease-in-out;</span><br><span class="hljs-comment">&#125;*/</span><br></code></pre></td></tr></table></figure><p>2.md中直接[TOC]，网页中无法自动生成。（失败）</p><h2 id="好看的主题"><a href="#好看的主题" class="headerlink" title="好看的主题"></a>好看的主题</h2><p> yearito，文章的标题目录 不自动合并。</p><p><img src="/2021/06/17/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20210712212342126.png" alt="image-20210712212342126"></p>]]></content>
    
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
